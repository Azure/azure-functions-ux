[
    {
        "id": "AppInsightsHttpAvailability-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "timerTrigger",
                    "name": "myTimer",
                    "direction": "in",
                    "schedule": "0 */5 * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpAvailability",
            "description": "$AppInsightsHttpAvailabilityCSharp_description",
            "name": "$AppInsightsHttpAvailability_name",
            "language": "C#",
            "category": [
                "$temp_category_monitoring",
                "$temp_category_samples"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "project.json": "{\n    \"frameworks\": {\n        \"net46\": {\n            \"dependencies\": {\n                \"Microsoft.ApplicationInsights\": \"2.3.0\"\n            }\n        }\n    }\n}\n",
            "readme.md": "# AppInsightsHttpAvailability - C<span>#</span>\n\nThe `AppInsightsHttpAvailability` makes it incredibly easy to have a custom function, \nwhich monitor availability and responsiveness of any web app with Application Insights executed on a schedule. \nThis sample demonstrates a simple use case of calling your web app every 5 minutes.\n\n> Note that you can also create multiple `AppInsightsHttpAvailability` function from multiple [Azure regions](https://azure.microsoft.com/en-us/regions) \n> to monitor the availability from multiple locations around the world.  \n> RunLocation will be configured accordingly from these regions.\n\n## How it works\n\nFor a `AppInsightsHttpAvailability` to work, \nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \nThe pattern we use to represent every 5 minutes is `0 */5 * * * *`. \nThis, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\n\nYou also have to provide the `Application Insights Instrumentation Key` by adding `AI_IKEY` in the `Application settings`.\n\n## Learn more\n\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)\n\n## Feedbacks or Questions\n\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\n",
            "run.csx": "using System.Configuration;\nusing System.Diagnostics;\n\nusing Microsoft.ApplicationInsights;\nusing Microsoft.ApplicationInsights.DataContracts;\n\n// This sample demonstrates a simple use case of calling your web app every 5 minutes.\n\n// Note that you can also create multiple functions from multiple [Azure regions](https://azure.microsoft.com/en-us/regions) \n// to monitor the availability from multiple locations around the world.\n// RunLocation will be configured accordingly from these regions.\n\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\n\n// setup synthetic headers used for client-server telemetry correlation\nprivate const string SyntheticTestId = \"SyntheticTest-Id\";\nprivate const string SyntheticTestRunId = \"SyntheticTest-RunId\";\nprivate const string SyntheticTestLocation = \"SyntheticTest-Location\";\n\n// [CONFIGURATION_REQUIRED] configure {AI_IKEY} accordingly in App Settings with Instrumentation Key obtained from Application Insights\n// [Get an Application Insights Instrumentation Key] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\nprivate static readonly TelemetryClient TelemetryClient = new TelemetryClient { InstrumentationKey = ConfigurationManager.AppSettings[\"AI_IKEY\"] };\n\n// [CONFIGURATION_REQUIRED] configure test timeout accordingly for which your request should run\nprivate static readonly HttpClient HttpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(30) };\n\npublic static async Task Run(TimerInfo myTimer, TraceWriter log)\n{\n    if (myTimer.IsPastDue)\n    {\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\n    }\n\n    // [CONFIGURATION_REQUIRED] provide {testName} accordingly for your test function\n    string testName = \"AvailabilityTestFunction\";\n    if (!HttpClient.DefaultRequestHeaders.Contains(SyntheticTestId))\n    {\n        HttpClient.DefaultRequestHeaders.Add(SyntheticTestId, testName);\n    }\n\n    // REGION_NAME is a default environment variable that comes with App Service\n    string location = Environment.GetEnvironmentVariable(\"REGION_NAME\");\n    if (!HttpClient.DefaultRequestHeaders.Contains(SyntheticTestLocation))\n    {\n        HttpClient.DefaultRequestHeaders.Add(SyntheticTestLocation, location);\n    }\n\n    // [CONFIGURATION_REQUIRED] configure {uri} and {contentMatch} accordingly for your web app\n    await AvailabilityTestRun(\n        name: testName,\n        location: location,\n        uri: \"https://azure.microsoft.com/en-us/services/application-insights\",\n        contentMatch: \"Application Insights\",\n        log: log\n    );\n}\n\nprivate static async Task AvailabilityTestRun(string name, string location, string uri, string contentMatch, TraceWriter log)\n{\n    log.Info($\"Executing availability test run for {name} at: {DateTime.Now}\");\n\n    // generate operation ID to allow issue tracking\n    string operationId = Guid.NewGuid().ToString();\n    log.Verbose($\"[Verbose]: Operation ID is {operationId}\");\n\n    // always update the run Id for every run\n    if (HttpClient.DefaultRequestHeaders.Contains(SyntheticTestRunId))\n    {\n        HttpClient.DefaultRequestHeaders.Remove(SyntheticTestRunId);\n    }\n\n    HttpClient.DefaultRequestHeaders.Add(SyntheticTestRunId, operationId);\n\n    var availability = new AvailabilityTelemetry\n    {\n        Id = operationId,\n        Name = name,\n        RunLocation = location,\n        Success = false\n    };\n    availability.Context.Operation.Id = operationId;\n    availability.Properties.Add(\"TestUri\", uri);\n    var stopwatch = new Stopwatch();\n    stopwatch.Start();\n    bool isMonitoringFailure = false;\n\n    try\n    {\n        using (var httpResponse = await HttpClient.GetAsync(uri))\n        {\n            // add test results to availability telemetry property\n            availability.Properties.Add(\"HttpResponseStatusCode\", Convert.ToInt32(httpResponse.StatusCode).ToString());\n\n            // check if response content contains specific text\n            string content = httpResponse.Content != null ? await httpResponse.Content.ReadAsStringAsync() : \"\";\n            availability.Properties.Add(\"HttpResponseContent\", content);\n            if (httpResponse.IsSuccessStatusCode && content.Contains(contentMatch))\n            {\n                availability.Success = true;\n                availability.Message = $\"Test succeeded with response: {httpResponse.StatusCode}\";\n                log.Verbose($\"[Verbose]: {availability.Message}\");\n            }\n            else if (!httpResponse.IsSuccessStatusCode)\n            {\n                availability.Message = $\"Test failed with response: {httpResponse.StatusCode}\";\n                log.Warning($\"[Warning]: {availability.Message}\");\n            }\n            else\n            {\n                availability.Message = $\"Test content does not contain: {contentMatch}\";\n                log.Warning($\"[Warning]: {availability.Message}\");\n            }\n        }\n    }\n    catch (TaskCanceledException e)\n    {\n        availability.Message = $\"Test timed out: {e.Message}\";\n        log.Warning($\"[Warning]: {availability.Message}\");\n    }\n    catch (Exception ex)\n    {\n        // track exception when unable to determine the state of web app\n        isMonitoringFailure = true;\n        var exceptionTelemetry = new ExceptionTelemetry(ex);\n        exceptionTelemetry.Context.Operation.Id = operationId;\n        exceptionTelemetry.Properties.Add(\"TestName\", name);\n        exceptionTelemetry.Properties.Add(\"TestLocation\", location);\n        exceptionTelemetry.Properties.Add(\"TestUri\", uri);\n        TelemetryClient.TrackException(exceptionTelemetry);\n        log.Error($\"[Error]: {ex.Message}\");\n\n        // optional - throw to fail the function\n        throw;\n    }\n    finally\n    {\n        stopwatch.Stop();\n        availability.Duration = stopwatch.Elapsed;\n        availability.Timestamp = DateTimeOffset.UtcNow;\n\n        // do not make assumption for the state of web app when is monitoring failure\n        if (!isMonitoringFailure)\n        {\n            TelemetryClient.TrackAvailability(availability);\n            log.Info($\"Availability telemetry for {name} is sent.\");\n        }\n\n        // call flush to ensure telemetries are sent\n        TelemetryClient.Flush();\n    }\n}"
        },
        "runtime": "1"
    },
    {
        "id": "AppInsightsRealtimePowerBI-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "timerTrigger",
                    "name": "myTimer",
                    "direction": "in",
                    "schedule": "0 * * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "RealtimePowerBI",
            "description": "$AppInsightsRealtimePowerBICSharp_description",
            "name": "$AppInsightsRealtimePowerBI_name",
            "language": "C#",
            "category": [
                "$temp_category_monitoring",
                "$temp_category_samples"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "readme.md": "# AppInsightsRealtimePowerBI - C<span>#</span>\n\nThe `AppInsightsRealtimePowerBI` makes it incredibly easy to push real-time data from Application Insights to Power BI. \nThis sample demonstrates a simple use case of getting real-time availability percentage \nover last 20 minutes on Power BI at per minute refresh with specified target availability percentage.\n\n> Note that you can also change the query to use different metrics/segments/aggregations/filters for your need  \n\n> Also note that about [API Rate limits](https://dev.applicationinsights.io/documentation/Authorization/Rate-limits)  \n> So it would be wise to disable the function (Your Function > Manage > Disabled) when not in use\n\n## How it works\n\nFor a `AppInsightsRealtimePowerBI` to work, \nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \nThe pattern we use to represent every day is `0 * * * * *`. \nThis, in plain text, means: \"When seconds is equal to 0, for any minute, hour, day of the month, month, day of the week, or year\".\n\nYou also have to provide the `Application Insights Application ID` and `Application Insights API Access KEY` with `Read telemetry` access, \nby adding `AI_APP_ID` and `AI_APP_KEY` in the `Application settings`.\n\nFor the Power BI to work, you need to provide the **Push URL** which can be obtained as follows:  \napp.powerbi.com > new dashboard > Add tile > Custom Streaming Data > Add streaming dataset > API > Next >  \nAdd a field with name `ts` and type DateTime (represents timestamp of calculation)  \nAdd a field with name `availability` and type Number (represents availability percentage for the interval)  \nAdd a field with name `target` and type Number (represents targeting percentage)  \nAdd a field with name `min` and type Number (represents minimum percentage)  \nAdd a field with name `max` and type Number (represents maximum percentage)  \nCreate > Copy the **\"Push URL\"** and paste it as the value of {RealTimePushURL}  \n\n## Learn more\n\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \nHere's how you can [Get your Application ID and API key](https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID)  \nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)  \nHere's where you can find out more about [Power BI REST API for real-time data push](https://msdn.microsoft.com/en-us/library/dn877544.aspx)  \nHere's where you can find out more about [Application Insights data access REST API](https://dev.applicationinsights.io/documentation/Using-the-API/Power-BI)  \n\n## Feedbacks or Questions\n\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\n",
            "run.csx": "#r \"Newtonsoft.Json\"\n\nusing System.Configuration;\nusing System.Text;\n\nusing Newtonsoft.Json.Linq;\n\n// This sample demonstrates a simple use case of getting real-time availability percentage \n// over last 20 minutes onto Power BI at per minute refresh with specified target availability percentage.\n\n// Note that you can also change the query to use different metrics/segments/aggregations/filters for your need\n\n// Also note that about [API Rate limits](https://dev.applicationinsights.io/documentation/Authorization/Rate-limits)\n// So it would be wise to disable the function (Your Function > Manage > Disabled) when not in use\n\n// For the Power BI to work, you need to provide the \"Push URL\" which can be obtained as follows:\n// app.powerbi.com > new dashboard > Add tile > Custom Streaming Data > Add streaming dataset > API > Next >\n// Add a field with name `ts` and type DateTime (represents timestamp of calculation)\n// Add a field with name `availability` and type Number (represents availability percentage for the interval)\n// Add a field with name `target` and type Number (represents targeting percentage)\n// Add a field with name `min` and type Number (represents minimum percentage)\n// Add a field with name `max` and type Number (represents maximum percentage)\n// Create > Copy the \"Push URL\" and paste it as the value of {RealTimePushURL}\n\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\n\nprivate const string AppInsightsApi = \"https://api.applicationinsights.io/beta/apps\";\n\n// [CONFIGURATION_REQUIRED] configure {RealTimePushURL} accordingly with values obtained from Power BI\n// [Get REST API URL endpoint] https://powerbi.microsoft.com/documentation/powerbi-service-real-time-streaming\nprivate const string RealTimePushURL = \"REAL_TIME_PUSH_URL\";\n\n// [CONFIGURATION_REQUIRED] configure {AI_APP_ID} and {AI_APP_KEY} accordingly in App Settings with values obtained from Application Insights\n// [Get your Application ID and API key] https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\nprivate static readonly string AiAppId = ConfigurationManager.AppSettings[\"AI_APP_ID\"];\nprivate static readonly string AiAppKey = ConfigurationManager.AppSettings[\"AI_APP_KEY\"];\n\npublic static async Task Run(TimerInfo myTimer, TraceWriter log)\n{\n    if (myTimer.IsPastDue)\n    {\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\n    }\n\n    log.Info($\"Executing real-time Power BI run at: {DateTime.Now}\");\n\n    // [CONFIGURATION_REQUIRED] update accordingly for your scenario\n    TimeSpan availabilityInterval = TimeSpan.FromMinutes(20);\n    double targetAvailability = 80;\n\n    using (var httpClient = new HttpClient())\n    {\n        // generate request ID to allow issue tracking\n        string requestId = Guid.NewGuid().ToString();\n        log.Verbose($\"[Verbose]: API request ID is {requestId}\");\n        httpClient.DefaultRequestHeaders.Add(\"x-api-key\", AiAppKey);\n        httpClient.DefaultRequestHeaders.Add(\"x-ms-app\", \"FunctionTemplate\");\n        httpClient.DefaultRequestHeaders.Add(\"x-ms-client-request-id\", requestId);\n        string metric = \"availabilityResults/count\";\n        string segment = \"availabilityResult/success\";\n        string aggregation = \"sum\";\n        string from = DateTime.UtcNow.Subtract(availabilityInterval).ToString(\"o\");\n        string to = DateTime.UtcNow.ToString(\"o\");\n        string apiPath = $\"{AppInsightsApi}/{AiAppId}/metrics/{metric}?useMDM=true&clientId={requestId}&timespan={from}/{to}&segment={segment}&aggregation={aggregation}\";\n        using (var httpResponse = await httpClient.GetAsync(apiPath))\n        {\n            httpResponse.EnsureSuccessStatusCode();\n            var resultJson = await httpResponse.Content.ReadAsAsync<JToken>();\n            JToken segments = resultJson.SelectToken(\"value.segments\");\n            int segmentCount = segments?.Count() ?? 0;\n            long[] results = new long[2];\n            for (int i = 0; i < segmentCount; i++)\n            {\n                int segmentValue = segments.SelectToken($\"[{i}].{segment}\").ToObject<int>();\n                results[segmentValue] = segments.SelectToken($\"[{i}].{metric}.{aggregation}\").ToObject<long>();\n            }\n\n            long passed = results[1];\n            long failed = results[0];\n            long total = passed + failed;\n            string availabilityPercentage = passed > 0 ? (100.0d * passed / total).ToString(\"N2\") : \"0\";\n            string postData = $\"[{{ \\\"ts\\\": \\\"{to}\\\", \\\"availability\\\": {availabilityPercentage}, \\\"target\\\": {targetAvailability}, \\\"min\\\": 0, \\\"max\\\": 100 }}]\";\n            log.Verbose($\"[Verbose]: Sending data: {postData}\");\n            using (var response = await httpClient.PostAsync(RealTimePushURL, new ByteArrayContent(Encoding.UTF8.GetBytes(postData))))\n            {\n                log.Verbose($\"[Verbose]: Data sent with response: {response.StatusCode}\");\n            }\n        }\n    }\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "AppInsightsScheduledAnalytics-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "timerTrigger",
                    "name": "myTimer",
                    "direction": "in",
                    "schedule": "0 */5 * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ScheduledAnalytics",
            "description": "$AppInsightsScheduledAnalyticsCSharp_description",
            "name": "$AppInsightsScheduledAnalytics_name",
            "language": "C#",
            "category": [
                "$temp_category_dataProcessing",
                "$temp_category_monitoring",
                "$temp_category_samples"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "project.json": "{\n    \"frameworks\": {\n        \"net46\": {\n            \"dependencies\": {\n                \"Microsoft.ApplicationInsights\": \"2.3.0\"\n            }\n        }\n    }\n}\n",
            "readme.md": "# AppInsightsScheduledAnalytics - C<span>#</span>\n\nThe `AppInsightsScheduledAnalytics` makes it incredibly easy to generate derived metric from your query. \nThis sample demonstrates a simple use case of generating derived metric every 5 minutes.\n\n> Note that the idea with this derived metric is that you can easily use it to setup _query-like_ alerting or dashboard. \n> Another important usage of this is to support Autoscale, you can use this derived metric as the source for an Autoscale setting. \n> [Get started with auto scale by custom metric in Azure](https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-scale-by-custom-metric)\n\n## How it works\n\nFor a `AppInsightsScheduledAnalytics` to work, \nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \nThe pattern we use to represent every 5 minutes is `0 */5 * * * *`. \nThis, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\n\nYou also have to provide the `Application Insights Instrumentation Key`, \n`Application Insights Application ID` and `Application Insights API Access KEY` with `Read telemetry` access, \nby adding `AI_IKEY`, `AI_APP_ID` and `AI_APP_KEY` repectively in the `Application settings`.\n\nAlso please be sure to execute the query in `Application Insights Analytics` portal first for validation of the query!\n\n## Learn more\n\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \nHere's how you can [Get your Application ID and API key](https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID)  \nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)  \nHere's how you can [Setup alerts](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-alerts)  \nHere's where you can find out more about [Application Insights Analytics](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics)  \nHere's where you can find out more about [Application Insights Dashboards](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-dashboards)\n\n## Feedbacks or Questions\n\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\n",
            "run.csx": "#r \"Newtonsoft.Json\"\n\nusing System.Configuration;\n\nusing Microsoft.ApplicationInsights;\nusing Microsoft.ApplicationInsights.DataContracts;\nusing Newtonsoft.Json.Linq;\n\n// This sample demonstrates a simple use case of generating derived metric every 5 minutes.\n\n// Note that the idea with this derived metric is that you can easily use it to setup _query-like_ alerting or dashboard.\n// Another important usage of this is to support Autoscale, you can use this derived metric as the source for an Autoscale setting.\n// [Get started with auto scale by custom metric in Azure] https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-scale-by-custom-metric\n\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\n\nprivate const string AppInsightsApi = \"https://api.applicationinsights.io/beta/apps\";\n\n// [CONFIGURATION_REQUIRED] configure {AI_IKEY} accordingly in App Settings with Instrumentation Key obtained from Application Insights\n// [Get an Application Insights Instrumentation Key] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\nprivate static readonly TelemetryClient TelemetryClient = new TelemetryClient { InstrumentationKey = ConfigurationManager.AppSettings[\"AI_IKEY\"] };\n\n// [CONFIGURATION_REQUIRED] configure {AI_APP_ID} and {AI_APP_KEY} accordingly in App Settings with values obtained from Application Insights\n// [Get your Application ID and API key] https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID\nprivate static readonly string AiAppId = ConfigurationManager.AppSettings[\"AI_APP_ID\"];\nprivate static readonly string AiAppKey = ConfigurationManager.AppSettings[\"AI_APP_KEY\"];\n\npublic static async Task Run(TimerInfo myTimer, TraceWriter log)\n{\n    if (myTimer.IsPastDue)\n    {\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\n    }\n\n    // [CONFIGURATION_REQUIRED] update the query accordingly for your need\n    // be sure to run it against Application Insights Analytics portal first for validation\n    // output should be a number if sending derived metrics\n    // [Application Insights Analytics] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics\n    await ScheduledAnalyticsRun(\n        name: \"ScheduledAnalyticsFunction\",\n        query: @\"\nrequests \n| where timestamp > ago(1h) \n| summarize passed = countif(success == true), total = count() \n| project passed * 1.0 / total * 100\n\",\n        log: log\n    );\n}\n\nprivate static async Task ScheduledAnalyticsRun(string name, string query, TraceWriter log)\n{\n    log.Info($\"Executing scheduled analytics run for {name} at: {DateTime.Now}\");\n\n    // generate request ID to allow issue tracking\n    string requestId = Guid.NewGuid().ToString();\n    log.Verbose($\"[Verbose]: API request ID is {requestId}\");\n\n    try\n    {\n        MetricTelemetry metric = new MetricTelemetry { Name = name };\n        metric.Context.Operation.Id = requestId;\n        metric.Properties.Add(\"TestAppId\", AiAppId);\n        metric.Properties.Add(\"TestQuery\", query);\n        metric.Properties.Add(\"TestRequestId\", requestId);\n        using (var httpClient = new HttpClient())\n        {\n            httpClient.DefaultRequestHeaders.Add(\"x-api-key\", AiAppKey);\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-app\", \"FunctionTemplate\");\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-client-request-id\", requestId);\n            string apiPath = $\"{AppInsightsApi}/{AiAppId}/query?clientId={requestId}&timespan=P1D&query={query}\";\n            using (var httpResponse = await httpClient.GetAsync(apiPath))\n            {\n                // throw exception when unable to determine the metric value\n                httpResponse.EnsureSuccessStatusCode();\n                var resultJson = await httpResponse.Content.ReadAsAsync<JToken>();\n                double result;\n                if (double.TryParse(resultJson.SelectToken(\"Tables[0].Rows[0][0]\")?.ToString(), out result))\n                {\n                    metric.Sum = result;\n                    log.Verbose($\"[Verbose]: Metric result is {metric.Sum}\");\n                }\n                else\n                {\n                    log.Error($\"[Error]: {resultJson.ToString()}\");\n                    throw new FormatException(\"Query must result in a single metric number. Try it on Analytics before scheduling.\");\n                }\n            }\n        }\n\n        TelemetryClient.TrackMetric(metric);\n        log.Info($\"Metric telemetry for {name} is sent.\");\n    }\n    catch (Exception ex)\n    {\n        // track exception when unable to determine the metric value\n        var exceptionTelemetry = new ExceptionTelemetry(ex);\n        exceptionTelemetry.Context.Operation.Id = requestId;\n        exceptionTelemetry.Properties.Add(\"TestName\", name);\n        exceptionTelemetry.Properties.Add(\"TestAppId\", AiAppId);\n        exceptionTelemetry.Properties.Add(\"TestQuery\", query);\n        exceptionTelemetry.Properties.Add(\"TestRequestId\", requestId);\n        TelemetryClient.TrackException(exceptionTelemetry);\n        log.Error($\"[Error]: Client Request ID {requestId}: {ex.Message}\");\n\n        // optional - throw to fail the function\n        throw;\n    }\n    finally\n    {\n        TelemetryClient.Flush();\n    }\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "AppInsightsScheduledDigest-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "timerTrigger",
                    "name": "myTimer",
                    "direction": "in",
                    "schedule": "0 0 2 * * *"
                },
                {
                    "type": "sendGrid",
                    "name": "$return",
                    "direction": "out",
                    "apiKey": "SendGridApiKey",
                    "from": "Application Insights <ai-noreply@mail.windowsazure.com>",
                    "to": "{EmailAddressToReceiveDigestReport}"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ScheduledDigest",
            "description": "$AppInsightsScheduledDigestCSharp_description",
            "name": "$AppInsightsScheduledDigest_name",
            "language": "C#",
            "category": [
                "$temp_category_monitoring",
                "$temp_category_samples"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "to",
                "from",
                "apiKey",
                "schedule"
            ]
        },
        "files": {
            "readme.md": "# AppInsightsScheduledDigest - C<span>#</span>\n\nThe `AppInsightsScheduledDigest` makes it incredibly easy to customize your digest emails and execute it on configurable schedule. \nThis sample demonstrates a simple use case of getting digest email once a day.\n\n> Note that you can also update the query for weekly or monthly digest reports, or even to provide deeper insights.\n\n## How it works\n\nFor a `AppInsightsScheduledDigest` to work, \nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \nThe pattern we use to represent every day is `0 0 2 * * *`. \nThis, in plain text, means: \"When seconds is equal to 0, minutes is equal to 0, hours is equal to 2, for any day of the month, month, day of the week, or year\".\n\nYou also have to provide the `Application Insights Application ID` and `Application Insights API Access KEY` with `Read telemetry` access, \nby adding `AI_APP_ID` and `AI_APP_KEY` in the `Application settings`.\n\nAlso note that if you are updating the query, be sure to run it through `Application Insights Analytics` portal first for validation of the query!\n\nFor the email to work, you need to provide the `SendGridApiKey` in the `Application settings`. \nThe one in the `function.json` points to the `Key Name` in the `Application Settings`, \nso create a `Key` named `SendGridApiKey` with the value for the API Key obtained from `SendGrid`.\n\n## Learn more\n\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \nHere's how you can [Get your Application ID and API key](https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID)  \nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)  \nHere's where you can find out more about [SendGrid API Key](https://sendgrid.com/docs/Classroom/Basics/API/what_is_my_api_key.html)\n\n## Feedbacks or Questions\n\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\n",
            "run.csx": "#r \"Newtonsoft.Json\"\n#r \"SendGrid\"\n\nusing System.Configuration;\n\nusing Newtonsoft.Json.Linq;\nusing SendGrid.Helpers.Mail;\n\n// This sample demonstrates a simple use case of getting digest email once a day.\n\n// Note that you can also update the query for weekly or monthly digest reports, or even to provide deeper insights.\n\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\n\nprivate const string AppInsightsApi = \"https://api.applicationinsights.io/beta/apps\";\n\n// [CONFIGURATION_REQUIRED] configure {AI_APP_ID} and {AI_APP_KEY} accordingly in App Settings with values obtained from Application Insights\n// [Get your Application ID and API key] https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\nprivate static readonly string AiAppId = ConfigurationManager.AppSettings[\"AI_APP_ID\"];\nprivate static readonly string AiAppKey = ConfigurationManager.AppSettings[\"AI_APP_KEY\"];\n\n// [CONFIGURATION_REQUIRED] configure {SendGridApiKey} accordingly in App Settings with API Key obtained from SendGrid\n// [Obtain SendGrid API Key] https://sendgrid.com/docs/Classroom/Basics/API/what_is_my_api_key.html\npublic static async Task<Mail> Run(TimerInfo myTimer, TraceWriter log)\n{\n    if (myTimer.IsPastDue)\n    {\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\n    }\n\n    DigestResult result = await ScheduledDigestRun(\n        query: GetQueryString(),\n        log: log\n    );\n\n    // [CONFIGURATION_REQUIRED] configure {appName} accordingly for your app/email\n    string appName = \"Your\";\n    var today = DateTime.Today.ToShortDateString();\n    Content content = new Content\n    {\n        Type = \"text/html\",\n        Value = GetHtmlContentValue(appName, today, result)\n    };\n    Mail message = new Mail()\n    {\n        Subject = $\"Your daily Application Insights digest report for {today}\"\n    };\n    message.AddContent(content);\n\n    log.Info($\"Generating daily report for {today} at {DateTime.Now}\");\n    return message;\n}\n\nprivate static async Task<DigestResult> ScheduledDigestRun(string query, TraceWriter log)\n{\n    log.Info($\"Executing scheduled daily digest run at: {DateTime.Now}\");\n\n    // generate request ID to allow issue tracking\n    string requestId = Guid.NewGuid().ToString();\n    log.Verbose($\"[Verbose]: API request ID is {requestId}\");\n\n    try\n    {\n        using (var httpClient = new HttpClient())\n        {\n            httpClient.DefaultRequestHeaders.Add(\"x-api-key\", AiAppKey);\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-app\", \"FunctionTemplate\");\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-client-request-id\", requestId);\n            string apiPath = $\"{AppInsightsApi}/{AiAppId}/query?clientId={requestId}&timespan=P1W&query={query}\";\n            using (var httpResponse = await httpClient.GetAsync(apiPath))\n            {\n                // throw exception when unable to determine the metric value\n                httpResponse.EnsureSuccessStatusCode();\n                var resultJson = await httpResponse.Content.ReadAsAsync<JToken>();\n                DigestResult result = new DigestResult\n                {\n                    TotalRequests = resultJson.SelectToken(\"Tables[0].Rows[0][0]\")?.ToObject<long>().ToString(\"N0\"),\n                    FailedRequests = resultJson.SelectToken(\"Tables[0].Rows[0][1]\")?.ToObject<long>().ToString(\"N0\"),\n                    RequestsDuration = resultJson.SelectToken(\"Tables[0].Rows[0][2]\")?.ToString(),\n                    TotalDependencies = resultJson.SelectToken(\"Tables[0].Rows[0][3]\")?.ToObject<long>().ToString(\"N0\"),\n                    FailedDependencies = resultJson.SelectToken(\"Tables[0].Rows[0][4]\")?.ToObject<long>().ToString(\"N0\"),\n                    DependenciesDuration = resultJson.SelectToken(\"Tables[0].Rows[0][5]\")?.ToString(),\n                    TotalViews = resultJson.SelectToken(\"Tables[0].Rows[0][6]\")?.ToObject<long>().ToString(\"N0\"),\n                    TotalExceptions = resultJson.SelectToken(\"Tables[0].Rows[0][7]\")?.ToObject<long>().ToString(\"N0\"),\n                    OverallAvailability = resultJson.SelectToken(\"Tables[0].Rows[0][8]\")?.ToString(),\n                    AvailabilityDuration = resultJson.SelectToken(\"Tables[0].Rows[0][9]\")?.ToString()\n                };\n                return result;\n            }\n        }\n    }\n    catch (Exception ex)\n    {\n        log.Error($\"[Error]: Client Request ID {requestId}: {ex.Message}\");\n\n        // optional - throw to fail the function\n        throw;\n    }\n}\n\nprivate static string GetQueryString()\n{\n    // update the query accordingly for your need (be sure to run it against Application Insights Analytics portal first for validation)\n    // [Application Insights Analytics] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics\n    return @\"\nrequests\n| where timestamp > ago(1d)\n| summarize Row = 1, TotalRequests = sum(itemCount), FailedRequests = sum(toint(success == 'False')),\n    RequestsDuration = iff(isnan(avg(duration)), '------', tostring(toint(avg(duration) * 100) / 100.0))\n| join (\ndependencies\n| where timestamp > ago(1d)\n| summarize Row = 1, TotalDependencies = sum(itemCount), FailedDependencies = sum(success == 'False'),\n    DependenciesDuration = iff(isnan(avg(duration)), '------', tostring(toint(avg(duration) * 100) / 100.0))\n) on Row | join (\npageViews\n| where timestamp > ago(1d)\n| summarize Row = 1, TotalViews = sum(itemCount)\n) on Row | join (\nexceptions\n| where timestamp > ago(1d)\n| summarize Row = 1, TotalExceptions = sum(itemCount)\n) on Row | join (\navailabilityResults\n| where timestamp > ago(1d)\n| summarize Row = 1, OverallAvailability = iff(isnan(avg(toint(success))), '------', tostring(toint(avg(toint(success)) * 10000) / 100.0)),\n    AvailabilityDuration = iff(isnan(avg(duration)), '------', tostring(toint(avg(duration) * 100) / 100.0))\n) on Row\n| project TotalRequests, FailedRequests, RequestsDuration, TotalDependencies, FailedDependencies, DependenciesDuration, TotalViews, TotalExceptions, OverallAvailability, AvailabilityDuration\n\";\n}\n\nprivate static string GetHtmlContentValue(string appName, string today, DigestResult result)\n{\n    // update the HTML template accordingly for your need\n    return $@\"\n<html><body>\n<p style='text-align: center;'><strong>{appName} daily telemetry report {today}</strong></p>\n<p style='text-align: center;'>The following data shows insights based on telemetry from last 24 hours.</p>\n<table align='center' style='width: 95%; max-width: 480px;'><tbody>\n<tr>\n<td style='min-width: 150px; text-align: left;'><strong>Total requests</strong></td>\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalRequests}</strong></td>\n</tr>\n<tr>\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Failed requests</td>\n<td style='min-width: 100px; text-align: right;'>{result.FailedRequests}</td>\n</tr>\n<tr>\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Average response time</td>\n<td style='min-width: 100px; text-align: right;'>{result.RequestsDuration} ms</td>\n</tr>\n<tr>\n<td colspan='2'><hr /></td>\n</tr>\n<tr>\n<td style='min-width: 150px; text-align: left;'><strong>Total dependencies</strong></td>\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalDependencies}</strong></td>\n</tr>\n<tr>\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Failed dependencies</td>\n<td style='min-width: 100px; text-align: right;'>{result.FailedDependencies}</td>\n</tr>\n<tr>\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Average response time</td>\n<td style='min-width: 100px; text-align: right;'>{result.DependenciesDuration} ms</td>\n</tr>\n<tr>\n<td colspan='2'><hr /></td>\n</tr>\n<tr>\n<td style='min-width: 150px; text-align: left;'><strong>Total views</strong></td>\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalViews}</strong></td>\n</tr>\n<tr>\n<td style='min-width: 150px; text-align: left;'><strong>Total exceptions</strong></td>\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalExceptions}</strong></td>\n</tr>\n<tr>\n<td colspan='2'><hr /></td>\n</tr>\n<tr>\n<td style='min-width: 150px; text-align: left;'><strong>Overall Availability</strong></td>\n<td style='min-width: 100px; text-align: right;'><strong>{result.OverallAvailability} %</strong></td>\n</tr>\n<tr>\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Average response time</td>\n<td style='min-width: 100px; text-align: right;'>{result.AvailabilityDuration} ms</td>\n</tr>\n</tbody></table>\n</body></html>\n\";\n}\n\nprivate struct DigestResult\n{\n    public string TotalRequests;\n    public string FailedRequests;\n    public string RequestsDuration;\n    public string TotalDependencies;\n    public string FailedDependencies;\n    public string DependenciesDuration;\n    public string TotalViews;\n    public string TotalExceptions;\n    public string OverallAvailability;\n    public string AvailabilityDuration;\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "BlobTrigger-Batch",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "inputBlob",
                    "type": "blobTrigger",
                    "direction": "in",
                    "path": "incontainer/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "BlobTrigger",
            "description": "$BlobTriggerBatch_description",
            "defaultFunctionName": "BlobTriggerBatch",
            "language": "Batch",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "run.bat": "echo OFF\nFOR /F \"usebackq\" %%i IN ('%inputBlob%') DO set size=%%~zi\necho Blob trigger function Processed, blob size:%size% bytes",
            "sample.dat": "incontainer/sample.txt"
        },
        "runtime": "1"
    },
    {
        "id": "BlobTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myBlob",
                    "type": "blobTrigger",
                    "direction": "in",
                    "path": "samples-workitems/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "BlobTrigger",
            "description": "$BlobTriggerCSharp_description",
            "defaultFunctionName": "BlobTriggerCSharp",
            "language": "C#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "readme.md": "# BlobTrigger - C<span>#</span>\n\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using C#.\n\n## How it works\n\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\n\n## Learn more\n\n<TODO> Documentation",
            "run.csx": "public static void Run(Stream myBlob, string name, TraceWriter log)\r\n{\r\n    log.Info($\"C# Blob trigger function Processed blob\\n Name:{name} \\n Size: {myBlob.Length} Bytes\");\r\n}\n",
            "sample.dat": "samples-workitems/workitem.txt"
        },
        "runtime": "1"
    },
    {
        "id": "BlobTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myBlob",
                    "type": "blobTrigger",
                    "direction": "in",
                    "path": "samples-workitems/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "BlobTrigger",
            "description": "$BlobTriggerFSharp_description",
            "defaultFunctionName": "BlobTriggerFSharp",
            "language": "F#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "readme.md": "# BlobTrigger - FSharp\n\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using F#.\n\n## How it works\n\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\n\n## Learn more\n\n<TODO> Documentation",
            "run.fsx": "open System\n\nlet Run(myBlob: Stream, name: string, log: TraceWriter) =\n    log.Verbose(sprintf \"F# Blob trigger function processed blob\\n Name: %s \\n Size: %d Bytes\" name myBlob.Length)\n",
            "sample.dat": "samples-workitems/workitem.txt"
        },
        "runtime": "1"
    },
    {
        "id": "BlobTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myBlob",
                    "type": "blobTrigger",
                    "direction": "in",
                    "path": "samples-workitems/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "BlobTrigger",
            "description": "$BlobTriggerNodeJS_description",
            "defaultFunctionName": "BlobTriggerJS",
            "language": "JavaScript",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, myBlob) {\n    context.log(\"JavaScript blob trigger function processed blob \\n Name:\", context.bindingData.name, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\n    context.done();\n};",
            "readme.md": "# BlobTrigger - JavaScript\n\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using JavaScript.\n\n## How it works\n\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\n\n## Learn more\n\n<TODO> Documentation",
            "sample.dat": "samples-workitems/workitem.txt"
        },
        "runtime": "1"
    },
    {
        "id": "BlobTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myBlob",
                    "type": "blobTrigger",
                    "direction": "in",
                    "path": "samples-workitems/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "BlobTrigger",
            "description": "$BlobTriggerNodeTS_description",
            "defaultFunctionName": "BlobTriggerTS",
            "language": "TypeScript",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, myBlob: any): void {\n    context.log(`TypeScript blob trigger function processed blob \nName: ${context.bindingData.name}\nBlob Size: ${myBlob.length} Bytes`);\n    context.done();\n};",
            "readme.md": "# BlobTrigger - TypeScript\n\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using TypeScript.\n\n## How it works\n\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\n\n## Learn more\n\n<TODO> Documentation",
            "sample.dat": "samples-workitems/workitem.txt"
        },
        "runtime": "1"
    },
    {
        "id": "CDS-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in"
                },
                {
                    "name": "res",
                    "type": "http",
                    "direction": "out"
                }
            ]
        },
        "metadata": {
            "name": "Cds WebHook",
            "description": "$cdsWebHookCSharp_description",
            "defaultFunctionName": "CdsWebHookCSharp",
            "language": "C#",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ],
            "warning": {
                "type": "Warning",
                "text": "$cdsTemplate_warningNotConfigured",
                "addLinkToAuth": true
            }
        },
        "files": {
            "project.json": "{\n  \"frameworks\": {\n    \"net46\":{\n        \"dependencies\": {\n            \"Castle.Core\": \"3.3.3\",\n            \"Google.Protobuf\": \"3.0.0\",\n            \"Microsoft.AspNet.WebApi.Client\": \"5.2.3\",\n            \"Microsoft.CommonDataService\": \"1.0.188-preview\",\n            \"Microsoft.IdentityModel.Clients.ActiveDirectory\": \"3.13.8\",\n            \"Newtonsoft.Json\": \"9.0.1\",\n            \"Microsoft.IdentityModel.Logging\": \"1.1.3\",\n            \"System.IdentityModel.Tokens.Jwt\": \"5.1.3\",\n            \"Microsoft.IdentityModel.Tokens\": \"5.1.3\"\n        }\n    }\n  }\n}\n",
            "readme.md": "# Common Data Service CSharp template\n\nThe Common Data Service CSharp template facilitates creating functions that perform complex business logic against the CDS. It allows developers to program against the CDS CSharp SDK directly from Azure Functions.\n\nSetting up the function created from this template, requires a few additional steps for setting up and configuring CDS, Azure Active Directory, and additional tooling to test the function. You can also setup PowerApps to work against your function using the instructions below.\n\n# Get started with the Common Data Service CSharp template\n\n## Overview\nIt's easy to get started programming against the Common Data Service using the Azure Functions template. This topic walks you through getting your Common Data Service Azure Function up and running. \n\nThere are four key steps:\n\n1. **Database acquisition**. The Common Data Service is currently only available through **PowerApps**. You need to get access to a PowerApps environment and ensure it contains a database. This allows you to configure the SDK to access that database.\n1. **Application registration**. To give your Azure function access to the Common Data Service, you need to register a few applications in **Azure Active Directory**. This allows you to establish an identity for your applications and specify the permission levels they needs in order to access the APIs.\n1. **Azure Function creation, configuration and programming**. You can create and configure your [Azure Functions](https://azure.microsoft.com/en-us/services/functions/) from the web portal. There you will be able to use the appropriate Functions template, and configure the Common Data Service SDK's NuGet references, authentication, and target environment.\n1. **Console client application creation and configuration**. You can then run and debug your Azure Function by running the client console app and making HTTP calls to the Function. \n\nIn addition, you can use this function from a PowerApps application. There are two key steps:\n1. **PowerApps Custom API creation and configuration**. In order to call the Azure Function from an app, it first needs to be wrapped by a Custom API that defines its API structure and authentication settings.\n2. **PowerApps app building and testing**. The created custom API can be used to call the Azure Function from an app. You can create the app and configure a button control to connect with the custom API inside PowerApps Studio. Then you can also test calling the function from PowerApps Player. \n\n# Database acquisition\n\nThe Common Data Service is currently only available through PowerApps. You need to get access to a PowerApps environment and ensure it contains a database. This allows you to configure the SDK to access that database.\n\n## Prerequisites\n1. If you have already signed up for PowerApps, you can go to [PowerApps](https://powerapps.microsoft.com) and sign in. If you have not signed up yet, you can follow instructions to [sign up](https://powerapps.microsoft.com/en-us/tutorials/signup-for-powerapps/).\n1. Ensure you have admin access to an environment containing a Common Data Service database, by going to the [PowerApps](https://powerapps.microsoft.com) portal, clicking on the **gear icon** located on top right of the screen, then clicking on **Admin center**. If you do not have admin access to any environments containing a database, follow these instructions to [create a database](https://powerapps.microsoft.com/en-us/tutorials/create-database/).\n\n## Getting the environment ID\n\nAfter acquiring an environment that contains a database, you can use that environment's identifier to configure your SDK application. The **environment ID** can be found as part of the URI you are using to access the environment. Record this value as it will be used in the upcoming configuration step. An example of such a URI and environment Id are as follows:\n\n    URI: https://web.powerapps.com/environments/d1ec10fa-74d5-44e5-b0f7-e448e3ca7509/home\n    Environment ID: d1ec10fa-74d5-44e5-b0f7-e448e3ca7509\n\n# Application registration\n\nTo give your Azure Function access to the Common Data Service, you need to register a **Web app / API** applications in **Azure Active Directory**. This allows you to establish an identity for your applications and specify the permission level it needs to access the APIs. You will also need to register the applications calling the Azure function. In this guide, we will use a simple console application to call into the Azure function, for this step we will require a **Native application** registration. Later, as an advanced steps, we will configure a PowerApps Custom API to call the Function, which will require registering another **Web app / API**. All these apps will have to be configured in Azure AD with the correct **Required permissions** and **known client applications**, for the end-to-end flow to work correctly.\n\n## Prerequisites\n\nIf you have already signed up for an Azure subscription, go to [Azure portal](https://portal.azure.com) and ensure you can create an application registration under Azure Active Directory. If you cannot, go to the [Azure](https://azure.microsoft.com) site and sign up for a free trial.\n\n1. In [Azure portal](https://portal.azure.com) go to **Azure Active Directory** \n1. Click on **Properties** and copy the value of **Directory ID** and record it as config variable **AAD tenant** for upcoming steps. Alternatively, you can use the domain name from your AAD login email.\n\n## Azure function application registration\n\nFollow these steps to register and configure your Azure Function in Azure AD:\n\n1. Go back to **Azure Active Directory** then click on **App registrations**. \n1. Create the Azure function application resource that we will use to call into the Common Data Service directly:\n    1. Click on **Add** to see a Create pane.\n    1. Enter a **Name** for your Azure function application.\n    1. Select **Web app / API** as application type.\n    1. Add a **Sign-on URL**, it could be any valid URI string. For example: http://localhost.    \n    1. Click on **Create**.\n1. Open the registered app:\n    1. Search for your newly registered app by name.\n    1. Click on it after finding it in the list of applications.\n    1. Record configuration value **Function application ID** for upcoming steps.\n1. Get the application secret:\n    1. Click on **Keys** to open a new pane.\n    1. Add a new **Key description** like \"key\", set the **Duration** to \"Never expires\" and click **Save**.\n    1. Record configuration value for the **Function application secret** by copying and pasting contents of the **Value** cell.\n1. Setup **Required permissions** for connecting to the Common Data Service:\n    1. Click on **Required permissions** to open a new pane.\n    1. Click on **Add**.\n    1. Navigate to **Select an API**.\n    1. Search for and choose **Common Data Service**, then click **Select**. If you cannot find this service refer to the **Troubleshooting** section under **Required permissions service not found**.\n    1. Check all entries under **Delegated permissions**, then click **Select**.\n    1. Click on **Done** to finalize setting up permissions for this service.\n    1. Repeat the 3 steps above for **Windows Azure Service Management API**.\n1. Get the Function application's resource ID:\n    1. Open the application's JSON manifest directly, by clicking on **Manifest** on top of the registered app pane.\n    1. Record the config value **AAD function resource ID** from any entry under `identifierUris`. Following is an example: `https://[your_domain_name]/4598e084-55a7-4d57-88ae-59902d8e3a52`.\n1.  **Note** - Configuring **known client applications** must be performed after registering the other application(s). The step is needed for seamless propagation of required permissions to clients. After completing all registrations go to section **Add known applications to Azure Function app**.\n\n## Client application registration\n\nFollow these steps to register and configure your client application in Azure AD:\n\n1. Go back to **Azure Active Directory** then click on **App registrations**. \n1. Create the application resource that we will be used when prompting you to login:\n    1. Click on **Add** to see a Create pane.\n    1. Enter a **Name** for your client application.\n    1. Select **Native** as application type.\n    1. Add a **Redirect URI**, it could be any valid URI string. For example: http://localhost.\n    1. Record configuration value **Redirect URI** for upcoming steps.\n    1. Click on **Create**.\n1. Open the Registered app:\n    1. Search for your newly registered app by name.\n    1. Click on it after finding it in the list of applications.\n    1. Record configuration value **Application ID** for upcoming steps.\n1. Setup **Required permissions** for connecting to the Azure Function:\n    1. Click on **Required permissions** to open a new pane.\n    1. Click on **Add**.\n    1. Navigate to **Select an API**.\n    1. Search for and select **Name** of the Azure Function web app created in previous step, then click **Select**.\n    1. Check all boxes under **Delegated permissions** section, then click **Select**.\n    1. Click on **Done** to finalize setting up permissions for this service.    \n\n## Advanced - PowerApps Custom API application registration\n\nYou can skip these steps if you are not planning to use the Azure Function from PowerApps. If you are interested in using PowerApps, follow these steps to register and configure your PowerApps Custom API application in Azure AD:\n\n1. Go back to **Azure Active Directory** then click on **App registrations**. \n1. Create the application resource that we will be used during the PowerApps user login process:\n    1. Click on **Add** to see a Create pane.\n    1. Enter a **Name** for your registered client application.\n    1. Select **Web app / API** as application type.\n    1. Set **Sign on URL** to `https://msmanaged-na.consent.azure-apim.net/redirect`, and record it for upcoming steps.\n    1. Click on **Create**.\n1. Open the **Registered app**:\n    1. Search for your newly registered app by name\n    1. Click on it after finding it in the list of applications.\n    1. Record configuration value **Custom API application ID** for upcoming steps.\n1. Get the application secret:\n    1. Click on **Keys** to open a new pane.\n    1. Add a new **Key description** like \"key\", set the **Duration** to \"Never expires\" and click **Save**.\n    1. Record configuration value for the **Custom API application secret** by copying and pasting contents of the **Value** cell.\n1. Setup **Required permissions** for connecting to the Azure Function:\n    1. Click on **Required permissions** to open a new pane.\n    1. Click on **Add**.\n    1. Navigate to **Select an API**.\n    1. Search for and select **Name** of the Azure Function web app created in previous steps, then click **Select**.\n    1. Check all boxes under **Delegated permissions** section, then click **Select**.\n    1. Click on **Done** to finalize setting up permissions for this service.  \n\n## Add known applications to Azure Function app\n\nFor seamless propagation of required permissions to clients, setup **known client applications**. This means that the first time a user logs into a client application, they will be asked to provide all required permissions needed to run this flow. If you skip this step, you may have to manually authorize the use of the Common Data Service for each user.\n   \n1. Go back to **Azure Active Directory** then click on **App registrations**. \n1. Open the registered app:\n    1. Search for your Azure Function web app created in previous step.\n    1. Click on it after finding it in the list of applications.\n    1. Modify the application's JSON manifest directly, by clicking on **Manifest** on top of the registered app pane.\n    1. Click on **Download** and save a backup of the manifest, then click **Edit** to go back.\n    1. Get the application IDs for both your **Client application** and **PowerApps custom API application**.\n    1. Add client application IDs as JSON string entries under the JSON array named `knownClientApplications` while maintaining validity of the manifest, then click **Save**. The manifest will look similar to the following:\n\n```javascript\n  \"knownClientApplications\": [\n    \"f60bee48-2341-4528-a91c-ec97f3ded...\",\n    \"b3b3d65c-5cbf-4323-b32d-68fd40778...\"\n  ],\n```\n\n# Azure Function creation, configuration and programming\n\nYou can create and configure your [Azure Functions](https://azure.microsoft.com/en-us/services/functions/) from the web portal. There you will be able to use the CDS CSharp Functions template, and configure the Common Data Service for authentication, and target environment.\n\n## Prerequisites\n\nAs with the previous step you need an Azure subscription, and access to [Azure portal](https://portal.azure.com). If you don't already have a subscription, go to the [Azure](https://azure.microsoft.com) site and sign up for a free trial.\n\nEnsure you have the following configuration values from previous steps:\n\n1. **AAD tenant**. This value identifies the tenant your database resides in.\n1. **AAD function application ID**. This value identifies the AAD web app you registered earlier for the Azure function.\n1. **AAD function application secret**. This value identifies secret of the AAD web app you registered earlier for the Azure function.\n1. **PowerApps environment ID**. This value identifies the PowerApps environment that contains your target the Common Data Service database.\n1. **AAD function application resource URI**. This value uniquely identifies the function application your client application will be calling. Think of this as an alternative ID for you function's AAD application registration.\n\n## Azure Function creation and configuration\n\nAssuming you already have an Azure subscription set up, [create and open a new function app from Azure Portal](https://portal.azure.com/#create/Microsoft.FunctionApp):\n1. Enter a unique **App name**.\n1. Select your current **Subscription**.\n1. Select an existing **Resource group** or provide a unique name for a new one.\n1. Select the existing **Consumption Plan** as your hosting plan.\n1. Select the **Location** of the function.\n1. Select an existing **Storage account** or follow steps to create one.\n1. Click **Create**.\n1. Under **All resources** search for and select the app you created.\n\nCreate a and configure a new Azure function using templates:\n1. Click on **New Function** under Functions from the left pane.\n1. Select **CDS-CSharp** from the list of templates.\n1. Configure **Authentication / Authorization** based on Azure Active Directory for the function.\n    1. Click on the warning link to **Configure App Service Authentication / Authorization**.\n    1. Turn on **App Service Authentication**.\n    1. Select **Login with Azure Active Directory** under **Action to take when request is not authorized**.\n    1. Configure Azure Active Directory under **Authentication Providers**.\n        1. Click on **Azure Active Directory** to configure it.\n        1. Select **Advanced** under **Management mode**.\n        1. Enter the **AAD function application ID** value from previous steps under **Client ID**.\n        1. Enter the **AAD function application resource URI** value from previous stesps under **Issuer Url**.\n        1. Enter the **AAD function application secret** value from previous steps under **Client secret**.\n        1. Click **OK**\n    1. Click **Save** to finalize **Authentication / Authorization**.\n1. Change the **Autohrization level** to **Anonymous** to disable Function Keys, since we already configured authentication with Azure AD. Without this step, the function will not work.\n1. Name the new Function **UpdateProjectCategory**, and click **Create**.\n1. **Note** the sample code window opens under the header section marked with an **'f'** symbol.\n1. Record the configuration value **Function URL** for upcoming steps by clicking on **Get function URL** on the top right, and clicking copy.\n\nUpdate the template code:\n\n1. **PowerApps environment ID** should replace `[[Replace with PowerApps environment ID value]]`.\n1. Fix an issue with the function sample code:\n    1. Replace the line of code for assigning value to the `name` variable from this:\n\n        ```cs\n        dynamic data = await req.Content.ReadAsAsync<object>();\n        string name = data?.name;\n        ```\n\n        to this:\n\n        ```cs\n        string name = await req.Content.ReadAsAsync<string>();\n        ```\n\n1. Click **Save** at the top of the pane.\n\n# Console client app creation and configuration\n\n## Prerequisites\nTo create a new console project you'll need [Visual Studio 2015](https://www.visualstudio.com/) or above installed on your computer.\n\nEnsure you have the following configuration values from previous steps:\n\n1. **Function URL**. This value identifies location of the Azure Function.\n1. **AAD tenant**. This value identifies the tenant your database resides in.\n1. **AAD client console application ID**. This value identifies the AAD app you registered earlier for the client console application.\n1. **AAD client console application redirect URI**. This value specifies the redirect URI used when you are prompted to login.\n1. **AAD function application resource URI**. This value uniquely identifies the function application your client application will be calling. Think of this as an alternative ID for you function's AAD application registration.\n\n## Project creation and configuration\n\n1. Start **Visual Studio**.\n1. From the **File** menu select **New project**.\n1. In the **New Project** dialog box, click **Installed > Templates > Visual C#**.\n    1. Choose **Console Application**.\n    1. Make sure that .NET Framework 4.5.2 is selected as the target framework.\n    1. Specify a name for your project and create the new Visual Studio solution.\n1. Find your project in the Solution Explorer, right-click on it and select **Manage NuGet packages**. \n    1. Search for **Microsoft.AspNet.WebApi.Client**.\n    1. Select the **Microsoft.AspNet.WebApi.Client** NuGet package and click on **Install**, to get the latest package.\n    1. Proceed through the **License acceptance** dialog. **Note** that by clicking accept you are agreeing with all package license terms.\n    1. Repeat the last 3 steps for **Microsoft.IdentityModel.Clients.ActiveDirectory** and **Newtonsoft.Json**.\n\nFrom Solution Explorer, open the **Program.cs** file, and replace `using` statements on top with following code:\n\n```cs\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\n```\n\nIn **Program.cs**, copy the following code to replace the contents of **`Program`** class.\n\n```cs\n        public const string TenantNameOrId = \"[[Replace with AAD tenant value]]\";\n        public const string ClientAppId = \"[[Replace with AAD client application ID value]]\";\n        public const string RedirectUri = \"[[Replace with AAD client redirect URI value]]\";\n        public const string AzureHostedResetUriString = \"[[Replace with Function URL value]]\"; // Azure hosted Function URI\n        public const string FunctionResourceId = \"[[Replace with AAD function resource ID value]]\";\n\n        public static string Authority { get { return string.Format(AuthorityTemplate, TenantNameOrId); } }\n        private const string AuthorityTemplate = \"https://login.windows.net/{0}\";\n        public const string AuthorizationHeaderScheme = \"Bearer\";\n\n        static void Main(string[] args)\n        {\n            // Run operation as async function\n            UpdateEntityAsync().Wait();\n            Console.WriteLine(\"Press any key to continue ...\");\n            Console.ReadLine();\n        }\n\n        private static async Task UpdateEntityAsync()\n        {\n            // Get HTTP client and send request\n            var client = await GetHttpClientAsync();\n            var updateUriString = $\"{AzureHostedResetUriString}\";\n            var response = await client.PostAsJsonAsync(updateUriString, \"Surface\");\n            Console.WriteLine($\"Status: '{response.StatusCode}'\");\n            Console.WriteLine($\"Contents: {await response.Content.ReadAsStringAsync()}\");\n        }\n\n        private static async Task<HttpClient> GetHttpClientAsync()\n        {\n            // Prompt for login and create security token\n            var authenticationContext = new AuthenticationContext(Authority);\n            AuthenticationResult authenticationResult = await authenticationContext.AcquireTokenAsync(FunctionResourceId\n                , ClientAppId\n                , new Uri(RedirectUri)\n                , new PlatformParameters(PromptBehavior.Always));\n            var securityTokenString = authenticationResult.CreateAuthorizationHeader();\n\n            // Create and configure the HTTP client\n            var client = new HttpClient();\n            var authorizationHeaderParameter = securityTokenString.Replace(AuthorizationHeaderScheme + \" \", string.Empty);\n            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(AuthorizationHeaderScheme, authorizationHeaderParameter);\n            return client;\n        }\n```\n\nConfigure the target environment and security setting of the app by replacing the corresponding bracket text in code with configuration values:\n\n1. **AAD tenant** should replace `[[Replace with AAD tenant value]]`.\n1. **AAD client application ID** should replace `[[Replace with AAD client application ID value]]`.\n1. **AAD client application redirect URI** should replace `[[Replace with AAD client redirect URI value]]`.\n1. **Function URL** should replace `[[Replace with Function URL value]]`.\n1. **AAD function resource ID** should replace `[[Replace with AAD function resource ID value]]`. **Note** that this **Resource ID** value comes from the **Function application** not the **custom API application**, and will look like the following example: `https://[your_domain_name]/4598e084-55a7-4d57-88ae-59902d8e3abc`.\n\n### Compile and run the project\n\n1. Ensure the project compiles by right clicking on the project and clicking **Build**.\n1. Run the client code by clicking on **Start** or pressing **F5**.\n1. Login using **your credentials** when the Azure AD prompt appears. The first time you run the application, you will be prompted to allow the AAD application you registered earlier to access the services Common Data Service uses.\n1. Verify that the program runs and calls the Function.\n1. Verify that the function updates Product Categories as expected.\n1. **Note** that if you see log errors related to assembly loading please refer to **Assembly load issue after publish to Azure** in the troubleshooting section. \n\n# Advanced - PowerApps Custom API creation and configuration\nIn order to call the Azure Function from an app, it first needs to be wrapped by a Custom API that defines its API structure and authentication settings.\n\nPrepare the [swagger](http://swagger.io/) file that defines your function by copying the content below to a .json file and modifying the **host** value. You can get these values by going to the Azure Function edit page and clicking on **Copy function URL** on the top right.\n\n```javascript\n{\n  \"swagger\": \"2.0\",\n  \"info\": {\n    \"version\": \"v1\",\n    \"title\": \"ProductCategory\"\n  },\n  \"host\": \"[[Replace with Azure Function app name value]].azurewebsites.net\",\n  \"schemes\": [\n    \"https\"\n  ],\n  \"paths\": {    \n    \"/api/UpdateProductCategory\": {\n      \"post\": {\n        \"operationId\": \"UpdateProductCategory\",\n        \"consumes\": [],\n        \"produces\": [],\n        \"parameters\": [\n          {\n            \"name\": \"name\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n                \"type\" : \"string\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\"\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n  },\n  \"securityDefinitions\": {\n    \"oauth2\": {\n      \"type\": \"oauth2\",\n      \"flow\": \"implicit\",\n      \"authorizationUrl\": \"https://login.windows.net/common/oauth2/authorize\",\n      \"scopes\": {\n        \n      }\n    }\n  }\n}\n```\n\nNow you can create a cusom API to match the Azure Function from previous step.\n\n1. Go to the **Connections** tab in the [PowerApps](https://powerapps.microsoft.com) portal.\n1. Click on **New connection**, select the **Custom** tab on top, then click on **New custom API**.\n1. Select **Swagger API definition**, click on **Upload**, and select the .json file created in the previous step.\n1. Set the name to **ProductCategory**, and click on **Next**. \n1. Under **Authentication type** select **Azure Active Directory**.\n1. Set **Client id** to the **AAD custom API application ID**.\n1. Set **Client secret** to the **AAD custom API application secret**.\n1. Set **Resource URL** to the **AAD function resource ID**. **Note** that this **Resource ID** value comes from the **Function application** not the **custom API application**, and will look like the following example: `https://[your_domain_name]/4598e084-55a7-4d57-88ae-59902d8e3abc`.\n1. Click **Create**, and verify that the new Custom API is added to the list.\n\nCreate a connection for the Custom API as follows:\n1. On the newly created Custom API, click on the **'+'** action button.\n1. Click on **Create**, then login with your credentials.\n1. You should see an authorization page asking you to **Accept** terms of the app to accessing CDS on your behalf. \n\n# Advanced - PowerApps app building and testing \nThe created custom API can be used to call the Azure Function from an app. You can create the app and configure a button control to connect with the custom API inside PowerApps Studio. Then you can also test calling the function from PowerApps Player. \n\n1. Create an app\n    1. Click on **New app** in bottom left of the [PowerApps](https://powerapps.microsoft.com) portal.\n    1. Select **PowerApps Studio for web**, and click on **Phone layout** under **Common Data Service**, to create an app from CDS entities.\n    1. In the entity list select **Product category**, then **OK**.\n1. Add the custom API as a data source.\n    1. Go to **Content** tab and click on **Data sources**.\n    1. Click on **Add data source**, and select the **ProductCategory** connector.\n1. Wire the button to call the custom API.\n    1. On the **BrowseScreen** select the **BrowseGallery** and add a **Button** control and name it **Update**.\n    1. Select the button and change **OnSelect** value to `ProductCategory.UpdateProductCategory(ThisItem.Name); Refresh('Product category')`.\n1. Modify one of the fields to show the **Description** field.\n    1. Select one of the fields under **BrowseGaller**\n    1. Change the **Text** property value to `ThisItem.Description`\n1. Test the changes by running the app.\n    1. Press **F5** to preview the app.\n    1. Click on the **Update** button, and note that **Description** field of that record is updated. \n\n# Troubleshooting\n\nThis section contains the most common issues encountered and reported by consumers of this topic.\n\n## Required permissions service not found\n\nIn some AAD configurations, like with nested tenants, you may be unable to find the **Common Data Service** and **Windows Azure Service Management API** when setting up required permissions in the previous step. In such a case you need to modify the application's JSON manifest directly, by clicking on **Manifest** on top of the registered app pane. Add the following entries under the JSON array named `requiredResourceAccess` while maintaining validity of the manifest, then click **Save**.\n\n```javascript\n{\n    \"resourceAppId\": \"82f77645-8a66-4745-bcdf-9706824f9ad0\",\n    \"resourceAccess\": [\n    {\n        \"id\": \"4ae1b148-ab4d-496d-8183-9292090fcca4\",\n        \"type\": \"Scope\"\n    }\n    ]\n},\n{\n    \"resourceAppId\": \"797f4846-ba00-4fd7-ba43-dac1f8f63013\",\n    \"resourceAccess\": [\n    {\n        \"id\": \"41094075-9dad-400e-a0bd-54e686782033\",\n        \"type\": \"Scope\"\n    }\n    ]\n}\n```\n\n## Assembly load issue after publish to Azure\n\nIf you started from a Visual Studio Function Application project and published it to the Azure Functions portal, you might have an issue with assembly loading when the function gets called. The error might look like the following:\n\n```\nFunction completed (Failure, Id=00000000-0000-0000-0000-000000000007)\nException while executing function: Functions.UpdateProductCategory. Microsoft.CommonDataService.ServiceClient.Security: Could not load file or assembly 'Microsoft.CommonDataService.Common, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35' or one of its dependencies. The system cannot find the file specified.\n```\n\nThis issue can be resolve by deleting the **project.lock.json** file:\n1. Go to the **View files** tab on the top right of the pane.\n1. Select the filw named **project.lock.json**.\n1. Click **Delete** on top of the pane.\n1. Reissue the request from client.\n\n",
            "run.csx": "// Usage of this template is subject to license terms of the \n// Microsoft Common Data Service Software Development Kit (https://go.microsoft.com/fwlink/?linkid=842862).\n\n#load \".\\telemetrybridge.csx\"\n\nusing Microsoft.CommonDataService;\nusing Microsoft.CommonDataService.CommonEntitySets;\nusing Microsoft.CommonDataService.Configuration;\nusing Microsoft.CommonDataService.ServiceClient.Security;\nusing Microsoft.CommonDataService.ServiceClient.Security.Credentials;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\n\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, TraceWriter log)\n{\n    log.Info($\"C# CDS trigger function processed a request. RequestUri={req.RequestUri}\");\n\n    dynamic data = await req.Content.ReadAsAsync<object>();\n    string name = data?.name;\n\n    if (name == null)\n    {\n        return req.CreateResponse(HttpStatusCode.BadRequest, \"Please pass a name in the request body\");\n    }\n\n    var connection = new ConnectionSettings\n    {\n        Tenant = \"common\",\n        EnvironmentId = \"[[Replace with PowerApps environment ID value]]\",\n        Credentials = new UserImpersonationCredentialsSettings\n        {\n            ApplicationId = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_CLIENT_ID\"),\n            ApplicationSecret = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_CLIENT_SECRET\")\n        }\n    };\n\n    using (var client = await connection.CreateClient(req, new TraceWriterTelemetryBridge(log)))\n    {\n        // Query product categories for Surfaces and Phones\n        var query = client.GetRelationalEntitySet<ProductCategory>()\n            .CreateQueryBuilder()\n            .Where(pc => pc.Name == \"Surface\" || pc.Name == \"Phone\")\n            .Project(pc => pc.SelectField(f => f.CategoryId).SelectField(f => f.Name));\n\n        OperationResult<IReadOnlyList<ProductCategory>> queryResult = null;\n        client.CreateRelationalBatchExecuter(RelationalBatchExecutionMode.Transactional)\n            .Query(query, out queryResult)\n            .ExecuteAsync().Wait();\n\n        // Delete any Surfaces and Phones\n        var deleteExecutor = client.CreateRelationalBatchExecuter(RelationalBatchExecutionMode.Transactional);\n        foreach (var entry in queryResult.Result)\n        {\n            deleteExecutor.DeleteWithoutConcurrencyCheck(entry);\n        }\n        deleteExecutor.ExecuteAsync().Wait();\n\n        // Insert Surface and Phone product lines\n        var surfaceCategory = new ProductCategory() { Name = \"Surface\", Description = \"Surface product line\" };\n        var phoneCategory = new ProductCategory() { Name = \"Phone\", Description = \"Phone product line\" };\n        await client.CreateRelationalBatchExecuter(RelationalBatchExecutionMode.Transactional)\n            .Insert(surfaceCategory)\n            .Insert(phoneCategory)\n            .ExecuteAsync();\n\n        // Query for Surface and Phone Product lines\n        query = client.GetRelationalEntitySet<ProductCategory>()\n            .CreateQueryBuilder()\n            .Where(pc => pc.Name == name)\n            .OrderByAscending(pc => new object[] { pc.CategoryId })\n            .Project(pc => pc.SelectField(f => f.CategoryId).SelectField(f => f.Name).SelectField(f => f.Description));\n\n        await client.CreateRelationalBatchExecuter(RelationalBatchExecutionMode.Transactional)\n            .Query(query, out queryResult)\n            .ExecuteAsync();\n\n        // Update all selected Product Lines with description\n        var updateExecutor = client.CreateRelationalBatchExecuter(RelationalBatchExecutionMode.Transactional);\n        foreach (var entry in queryResult.Result)\n        {\n            log.Info($\"Updateing '{entry.Name}'.\");\n            var updateProductCategory = client.CreateRelationalFieldUpdates<ProductCategory>();\n            string updatedDescription = $\"{DateTime.Now.ToString()} - Updated '{entry.Name}'\";\n            updateProductCategory.Update(pc => pc.Description, updatedDescription);\n\n            updateExecutor.Update(entry, updateProductCategory);\n        }\n        await updateExecutor.ExecuteAsync();\n\n        log.Info($\"C# CDS trigger function completed.\");\n        return req.CreateResponse(HttpStatusCode.OK);\n    }\n}",
            "sample.dat": "{\n    \"name\": \"Surface\"\n}",
            "telemetrybridge.csx": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.WebJobs.Host;\nusing Microsoft.CommonDataService;\nusing Microsoft.CommonDataService.Common.Internal;\n\nclass TraceWriterTelemetryBridge : TraceWriter, ITelemetryService\n{\n    enum MessageLevel\n    {\n        Error,\n        Warning,\n        Info,\n        Verbose\n    }\n\n    private readonly TraceWriter logger;\n\n    public TraceWriterTelemetryBridge() : base(TraceLevel.Verbose)\n    {\n    }\n\n    public TraceWriterTelemetryBridge(TraceWriter log) : this()\n    {\n        logger = log;\n    }\n\n    private void WriteToTraceWriter(string message, MessageLevel messageLevel)\n    {\n        switch (messageLevel)\n        {\n            case MessageLevel.Error:\n                logger.Error(message);\n                break;\n            case MessageLevel.Warning:\n                logger.Warning(message);\n                break;\n            case MessageLevel.Info:\n                logger.Info(message);\n                break;\n            case MessageLevel.Verbose:\n                logger.Verbose(message);\n                break;\n        }\n    }\n\n    public override void Trace(TraceEvent traceEvent)\n    {\n        System.Diagnostics.Trace.TraceInformation(traceEvent.Message, traceEvent.Source);\n    }\n\n    public void TraceError(string message)\n    {\n        WriteToTraceWriter(message, MessageLevel.Error);\n    }\n\n    public void TraceError<T0>(string format, T0 arg0)\n    {\n        WriteToTraceWriter(string.Format(format, arg0), MessageLevel.Error);\n    }\n\n    public void TraceError<T0, T1>(string format, T0 arg0, T1 arg1)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1), MessageLevel.Error);\n    }\n\n    public void TraceError<T0, T1, T2>(string format, T0 arg0, T1 arg1, T2 arg2)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2), MessageLevel.Error);\n    }\n\n    public void TraceError<T0, T1, T2, T3>(string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2, arg3), MessageLevel.Error);\n    }\n\n    public void TraceFatal(string message)\n    {\n        WriteToTraceWriter(message, MessageLevel.Error);\n    }\n\n    public void TraceFatal<T0>(string format, T0 arg0)\n    {\n        WriteToTraceWriter(string.Format(format, arg0), MessageLevel.Error);\n    }\n\n    public void TraceFatal<T0, T1>(string format, T0 arg0, T1 arg1)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1), MessageLevel.Error);\n    }\n\n    public void TraceFatal<T0, T1, T2>(string format, T0 arg0, T1 arg1, T2 arg2)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2), MessageLevel.Error);\n    }\n\n    public void TraceFatal<T0, T1, T2, T3>(string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2, arg3), MessageLevel.Error);\n    }\n\n    public void TraceInformation(string message)\n    {\n        WriteToTraceWriter(message, MessageLevel.Info);\n    }\n\n    public void TraceInformation<T0>(string format, T0 arg0)\n    {\n        WriteToTraceWriter(string.Format(format, arg0), MessageLevel.Info);\n    }\n\n    public void TraceInformation<T0, T1>(string format, T0 arg0, T1 arg1)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1), MessageLevel.Info);\n    }\n\n    public void TraceInformation<T0, T1, T2>(string format, T0 arg0, T1 arg1, T2 arg2)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2), MessageLevel.Info);\n    }\n\n    public void TraceInformation<T0, T1, T2, T3>(string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2, arg3), MessageLevel.Info);\n    }\n\n    public void TraceVerbose(string message)\n    {\n        WriteToTraceWriter(message, MessageLevel.Verbose);\n    }\n\n    public void TraceVerbose<T0>(string format, T0 arg0)\n    {\n        WriteToTraceWriter(string.Format(format, arg0), MessageLevel.Verbose);\n    }\n\n    public void TraceVerbose<T0, T1>(string format, T0 arg0, T1 arg1)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1), MessageLevel.Verbose);\n    }\n\n    public void TraceVerbose<T0, T1, T2>(string format, T0 arg0, T1 arg1, T2 arg2)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2), MessageLevel.Verbose);\n    }\n\n    public void TraceVerbose<T0, T1, T2, T3>(string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2, arg3), MessageLevel.Verbose);\n    }\n\n    public void TraceWarning(string message)\n    {\n        WriteToTraceWriter(message, MessageLevel.Warning);\n    }\n\n    public void TraceWarning<T0>(string format, T0 arg0)\n    {\n        WriteToTraceWriter(string.Format(format, arg0), MessageLevel.Warning);\n    }\n\n    public void TraceWarning<T0, T1>(string format, T0 arg0, T1 arg1)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1), MessageLevel.Warning);\n    }\n\n    public void TraceWarning<T0, T1, T2>(string format, T0 arg0, T1 arg1, T2 arg2)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2), MessageLevel.Warning);\n    }\n\n    public void TraceWarning<T0, T1, T2, T3>(string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3)\n    {\n        WriteToTraceWriter(string.Format(format, arg0, arg1, arg2, arg3), MessageLevel.Warning);\n    }\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "EventHubTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "eventHubTrigger",
                    "name": "myEventHubMessage",
                    "direction": "in",
                    "path": "samples-workitems",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "EventHubTriggerCSharp",
            "description": "$EventHubTriggerCSharp_description",
            "name": "EventHubTrigger",
            "language": "C#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "run.csx": "using System;\n\npublic static void Run(string myEventHubMessage, TraceWriter log)\r\n{\r\n    log.Info($\"C# Event Hub trigger function processed a message: {myEventHubMessage}\");\r\n}\n",
            "sample.dat": "Test Message"
        },
        "runtime": "1"
    },
    {
        "id": "EventHubTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "eventHubTrigger",
                    "name": "myEventHubMessage",
                    "direction": "in",
                    "path": "samples-workitems",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "EventHubTriggerFSharp",
            "description": "$EventHubTriggerFSharp_description",
            "name": "EventHubTrigger",
            "language": "F#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "run.fsx": "open System\n\nlet Run(myEventHubMessage: string, log: TraceWriter) =\n    log.Info(sprintf \"F# Event Hub trigger function processed a message: %s\" myEventHubMessage)\n",
            "sample.dat": "Test Message"
        },
        "runtime": "1"
    },
    {
        "id": "EventHubTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "eventHubTrigger",
                    "name": "eventHubMessages",
                    "direction": "in",
                    "path": "samples-workitems",
                    "connection": "",
                    "cardinality": "many"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "EventHubTriggerJS",
            "description": "$EventHubTriggerNodeJS_description",
            "name": "EventHubTrigger",
            "language": "JavaScript",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, eventHubMessages) {\n    context.log(`JavaScript eventhub trigger function called for message array ${eventHubMessages}`);\n    \n    eventHubMessages.forEach(message => {\n        context.log(`Processed message ${message}`);\n    });\n\n    context.done();\n};",
            "sample.dat": "Test Message"
        },
        "runtime": "1"
    },
    {
        "id": "EventHubTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "eventHubTrigger",
                    "name": "eventHubMessages",
                    "direction": "in",
                    "path": "samples-workitems",
                    "connection": "",
                    "cardinality": "many"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "EventHubTriggerTS",
            "description": "$EventHubTriggerNodeTS_description",
            "name": "EventHubTrigger",
            "language": "TypeScript",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, eventHubMessages: any[]): void {\n    context.log(`TypeScript eventhub trigger function called for message array ${eventHubMessages}`);\n\n    eventHubMessages.forEach(message => {\n        context.log(`Processed message ${message}`);\n    });\n\n    context.done();\n};",
            "sample.dat": "Test Message"
        },
        "runtime": "1"
    },
    {
        "id": "ExternalFileTrigger-Batch",
        "function": {
            "bindings": [
                {
                    "type": "apiHubFileTrigger",
                    "name": "inputFile",
                    "direction": "in",
                    "path": "input-batch/{name}",
                    "connection": ""
                },
                {
                    "type": "apiHubFile",
                    "name": "outputFile",
                    "direction": "out",
                    "path": "output-batch/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ExternalFileTrigger",
            "description": "$SaasFileTriggerBatch_description",
            "defaultFunctionName": "ExternalFileTriggerBatch",
            "language": "Batch",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "run.bat": "@echo off\n\ncopy %inputFile% %outputFile%\n\necho Windows Batch script processed a file!",
            "sample.dat": "input-batch/{your file}\n\n"
        },
        "runtime": "1"
    },
    {
        "id": "ExternalFileTrigger-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "apiHubFileTrigger",
                    "name": "inputFile",
                    "direction": "in",
                    "path": "input-cs/{name}",
                    "connection": ""
                },
                {
                    "type": "apiHubFile",
                    "name": "$return",
                    "direction": "out",
                    "path": "output-cs/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ExternalFileTrigger",
            "description": "$SaasFileTriggerCSharp_description",
            "defaultFunctionName": "ExternalFileTriggerCSharp",
            "language": "C#",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "run.csx": "using System;\n\npublic static string Run(string inputFile, string name, TraceWriter log)\n{\n    log.Info($\"C# External trigger function processed file: \" + name);\n    return inputFile;\n}",
            "sample.dat": "input-cs/{your file}\n\n"
        },
        "runtime": "1"
    },
    {
        "id": "ExternalFileTrigger-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "apiHubFileTrigger",
                    "name": "input",
                    "direction": "in",
                    "path": "input-cs/{name}",
                    "connection": ""
                },
                {
                    "type": "apiHubFile",
                    "name": "$return",
                    "direction": "out",
                    "path": "output-cs/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ExternalFileTrigger",
            "description": "$SaasFileTriggerFSharp_description",
            "defaultFunctionName": "ExternalFileTriggerFSharp",
            "language": "F#",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "run.fsx": "let Run(input: string, name: string, log: TraceWriter) =\n    log.Info(sprintf \"F# External trigger function processed file: %s\" name)\n    input\n",
            "sample.dat": "input-cs/{your file}\n\n"
        },
        "runtime": "1"
    },
    {
        "id": "ExternalFileTrigger-JavaScript",
        "function": {
            "bindings": [
                {
                    "type": "apiHubFileTrigger",
                    "name": "inputFile",
                    "direction": "in",
                    "path": "input-javascript/{name}",
                    "connection": ""
                },
                {
                    "type": "apiHubFile",
                    "name": "outputFile",
                    "direction": "out",
                    "path": "output-javascript/{name}",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ExternalFileTrigger",
            "description": "$SaasFileTriggerNodeJS_description",
            "defaultFunctionName": "ExternalFileTriggerJS",
            "language": "JavaScript",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, inputFile) {\n    context.log('JavaScript External trigger function processed a file!');\n    context.done(null, {\n        outputFile: inputFile\n    });\n};\n",
            "sample.dat": "input-JavaScript/{your file}\n\n"
        },
        "runtime": "1"
    },
    {
        "id": "ExternalTable-CSharp",
        "function": {
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in"
                },
                {
                    "name": "res",
                    "type": "http",
                    "direction": "out"
                },
                {
                    "type": "apiHubTable",
                    "name": "inputTable",
                    "dataSetName": "default",
                    "tableName": "Contact",
                    "connection": "",
                    "direction": "in"
                }
            ]
        },
        "metadata": {
            "name": "ExternalTable",
            "description": "$SaasTableCSharp_description",
            "defaultFunctionName": "ExternalTableCSharp",
            "language": "C#",
            "category": [
                "$temp_category_experimental"
            ],
            "userPrompt": [
                "connection",
                "tableName"
            ]
        },
        "files": {
            "run.csx": "#r \"Microsoft.Azure.ApiHub.Sdk\" \n\nusing System;\nusing System.Net;\nusing Microsoft.Azure.ApiHub;\n\npublic class Contact\n{\n    public string Id { get; set; }\n    public string LastName { get; set; }\n    public string FirstName { get; set; }\n}\n\n\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, ITable<Contact> inputTable, TraceWriter log)\n{\n    log.Info(\"C# HTTP trigger function processed a request.\");\n    ContinuationToken continuationToken = null;\n    \n    do\n    {\n        var segment = await inputTable.ListEntitiesAsync(continuationToken: continuationToken);\n        foreach (var item in segment.Items)\n        {\n            log.Info(item.FirstName + \" \" + item.LastName);\n        }\n        continuationToken = segment.ContinuationToken; ;\n    }\n    while (continuationToken != null);\n\n    return req.CreateResponse(HttpStatusCode.OK);\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "ExternalTable-FSharp",
        "function": {
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in"
                },
                {
                    "name": "res",
                    "type": "http",
                    "direction": "out"
                },
                {
                    "type": "apiHubTable",
                    "name": "input",
                    "dataSetName": "default",
                    "tableName": "Contact",
                    "connection": "",
                    "direction": "in"
                }
            ]
        },
        "metadata": {
            "name": "ExternalTable",
            "description": "$SaasTableFSharp_description",
            "defaultFunctionName": "ExternalTableFSharp",
            "language": "F#",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "tableName"
            ]
        },
        "files": {
            "project.json": "{\n  \"frameworks\": {\n    \"net46\":{\n      \"dependencies\": {\n        \"Microsoft.Azure.ApiHub.Sdk\": \"0.6.2\"\n      }\n    }\n  }\n}\n",
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Microsoft.Azure.ApiHub.Sdk\" \n\nopen System.Net\nopen System.Net.Http\nopen Microsoft.Azure.ApiHub\n\ntype Contact() =\n    member val Id: string = null with get, set\n    member val FirstName: string = null with get, set\n    member val LastName: string = null with get, set\n\nlet Run(req: HttpRequestMessage, input: ITable<Contact>, log: TraceWriter) =\n    async {\n        log.Info(sprintf \n            \"F# HTTP trigger function processed a request.\")\n\n        let rec q (cont: ContinuationToken) = async {\n            let! segment =\n                input.ListEntitiesAsync(continuationToken = cont)\n                |> Async.AwaitTask\n            \n            for item in segment.Items do\n                log.Info(sprintf \"%s %s\" item.FirstName item.LastName)\n\n            match segment.ContinuationToken with\n            | null -> return ()\n            | token -> q token |> Async.RunSynchronously\n        }\n\n        q null |> Async.RunSynchronously\n        return req.CreateResponse(HttpStatusCode.OK)\n    } |> Async.StartAsTask\n"
        },
        "runtime": "1"
    },
    {
        "id": "FaceLocator-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "blobTrigger",
                    "name": "image",
                    "path": "images/{name}.jpg",
                    "connection": "",
                    "direction": "in"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "faceRectangle",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "FaceLocatorCSharp",
            "description": "$FaceLocatorCSharp_description",
            "name": "FaceLocator",
            "language": "C#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "path",
                "connection",
                "tableName"
            ]
        },
        "files": {
            "run.csx": "// Setup\n// 1) Go to https://www.microsoft.com/cognitive-services/en-us/computer-vision-api \n//    Sign up for computer vision api\n// 2) Go to Function app settings -> App Service settings -> Settings -> Application settings\n//    create a new app setting Vision_API_Subscription_Key and use Computer vision key as value\n\n#r \"Microsoft.WindowsAzure.Storage\"\n#r \"Newtonsoft.Json\"\n\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing Newtonsoft.Json;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing System.IO;\n\npublic static async Task Run(Stream image, string name, IAsyncCollector<FaceRectangle> outTable, TraceWriter log)\r\n{\r\n    string result = await CallVisionAPI(image);\r\n    log.Info(result);\r\n\r\n    if (String.IsNullOrEmpty(result))\r\n    {\r\n        return;\r\n    }\r\n\r\n    ImageData imageData = JsonConvert.DeserializeObject<ImageData>(result);\r\n    foreach (Face face in imageData.Faces)\r\n    {\r\n        var faceRectangle = face.FaceRectangle;\r\n        faceRectangle.RowKey = Guid.NewGuid().ToString();\r\n        faceRectangle.PartitionKey = \"Functions\";\r\n        faceRectangle.ImageFile = name + \".jpg\";\r\n        await outTable.AddAsync(faceRectangle);\r\n    }\r\n}\r\n\r\nstatic async Task<string> CallVisionAPI(Stream image)\r\n{\r\n    using (var client = new HttpClient())\r\n    {\r\n        var content = new StreamContent(image);\r\n        var url = \"https://api.projectoxford.ai/vision/v1.0/analyze?visualFeatures=Faces\";\r\n        client.DefaultRequestHeaders.Add(\"Ocp-Apim-Subscription-Key\", Environment.GetEnvironmentVariable(\"Vision_API_Subscription_Key\"));\r\n        content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\r\n        var httpResponse = await client.PostAsync(url, content);\r\n\r\n        if (httpResponse.StatusCode == HttpStatusCode.OK)\r\n        {\r\n            return await httpResponse.Content.ReadAsStringAsync();\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\npublic class ImageData\r\n{\r\n    public List<Face> Faces { get; set; }\r\n}\r\n\r\npublic class Face\r\n{\r\n    public int Age { get; set; }\r\n\r\n    public string Gender { get; set; }\r\n\r\n    public FaceRectangle FaceRectangle { get; set; }\r\n}\r\n\r\npublic class FaceRectangle : TableEntity\r\n{\r\n    public string ImageFile { get; set; }\r\n\r\n    public int Left { get; set; }\r\n\r\n    public int Top { get; set; }\r\n\r\n    public int Width { get; set; }\r\n\r\n    public int Height { get; set; }\r\n}\n",
            "sample.dat": "images/image.jpg"
        },
        "runtime": "1"
    },
    {
        "id": "FaceLocator-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "blobTrigger",
                    "name": "image",
                    "path": "images/{name}.jpg",
                    "connection": "",
                    "direction": "in"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "faceRectangle",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "FaceLocatorFSharp",
            "description": "$FaceLocatorFSharp_description",
            "name": "FaceLocator",
            "language": "F#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "path",
                "connection",
                "tableName"
            ]
        },
        "files": {
            "run.fsx": "// Setup\n// 1) Go to https://www.microsoft.com/cognitive-services/en-us/computer-vision-api \n//    Sign up for computer vision api\n// 2) Go to Function app settings -> App Service settings -> Settings -> Application settings\n//    create a new app setting Vision_API_Subscription_Key and use Computer vision key as value\n#r \"Microsoft.WindowsAzure.Storage\"\n#r \"Newtonsoft.Json\"\n#r \"System.Net.Http\"\n\nopen System\nopen System.Net\nopen System.Net.Http\nopen System.Net.Http.Headers\nopen System.IO\nopen Newtonsoft.Json\nopen Microsoft.WindowsAzure.Storage.Table\n\ntype FaceRectangle() =\n    inherit TableEntity()\n    member val ImageFile: string = null with get, set\n    member val Left: int = 0 with get, set\n    member val Top: int = 0 with get, set\n    member val Width: int = 0 with get, set\n    member val Height: int = 0 with get, set\n\ntype Face = {\n    Age: int\n    Gender: string\n    FaceRectangle: FaceRectangle\n}\n\ntype ImageData = {\n    Faces: Face list\n}\n\nlet callVisionAPI (image: Stream) = async {\n    use client = new HttpClient()\n    use content = new StreamContent(image)\n    let url = \"https://api.projectoxford.ai/vision/v1.0/analyze?visualFeatures=Faces\"\n\n    client.DefaultRequestHeaders.Add(\n        \"Ocp-Apim-Subscription-Key\",\n        Environment.GetEnvironmentVariable(\"Vision_API_Subscription_Key\"))\n    content.Headers.ContentType <-\n        new MediaTypeHeaderValue(\"application/octet-stream\");\n\n    let! httpResponse = client.PostAsync(url, content) |> Async.AwaitTask\n\n    if httpResponse.StatusCode = HttpStatusCode.OK then\n        return! httpResponse.Content.ReadAsStringAsync() |> Async.AwaitTask\n    else\n        return null\n}\n\nlet Run(image: Stream, name: string, outTable: IAsyncCollector<FaceRectangle>, log: TraceWriter) =\n    let result = callVisionAPI(image) |> Async.RunSynchronously\n    log.Info(result)\n\n    if not (String.IsNullOrEmpty(result)) then\n        let imageData = JsonConvert.DeserializeObject<ImageData>(result)\n        for face in imageData.Faces do\n            let faceRectangle = face.FaceRectangle\n            faceRectangle.RowKey <- Guid.NewGuid().ToString()\n            faceRectangle.PartitionKey <- \"Functions\"\n            faceRectangle.ImageFile <- name + \".jpg\"\n            outTable.AddAsync(faceRectangle)\n            |> Async.AwaitTask\n            |> Async.RunSynchronously\n",
            "sample.dat": "images/image.jpg"
        },
        "runtime": "1"
    },
    {
        "id": "FaceLocator-JavaScript",
        "function": {
            "bindings": [
                {
                    "type": "blobTrigger",
                    "name": "image",
                    "path": "images/{name}.jpg",
                    "dataType": "binary",
                    "connection": "",
                    "direction": "in"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "faceRectangle",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "FaceLocatorJS",
            "description": "$FaceLocatorNodeJS_description",
            "name": "FaceLocator",
            "language": "JavaScript",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "path",
                "connection",
                "tableName"
            ]
        },
        "files": {
            "index.js": "// Setup\n// 1) Go to https://www.microsoft.com/cognitive-services/en-us/computer-vision-api \n//    Sign up for computer vision api\n// 2) Go to Function app settings -> App Service settings -> Settings -> Application settings\n//    create a new app setting Vision_API_Subscription_Key and use Computer vision key as value\n// 3) Go to Function app settings -> App Service settings -> Tools -> Console\n//    Enter the following commands: \n//    > cd <functionName>\n//    > npm install\nvar request = require('request-promise');\nvar guid = require('node-uuid');\n\nmodule.exports = function (context, image) {\n\n    context.log(\"Image Size:\", image.length);\n    var options = {\n        uri: \"https://api.projectoxford.ai/vision/v1.0/analyze?visualFeatures=Faces\",\n        method: 'POST',\n        body: image,\n        headers: {\n            'Content-Type': 'application/octet-stream',\n            'Ocp-Apim-Subscription-Key': process.env.Vision_API_Subscription_Key\n        }\n    };\n\n    request(options)\n        .then((response) => {\n            response = JSON.parse(response);\n\n            if (!response || !response.faces.length) {\n                return context.done();\n            }\n\n            context.log(\"From Vision Api:\", response);\n\n            context.bindings.outTable = response.faces.map((face) => {\n                var faceMapping = {\n                    rowKey: guid.v1(),\n                    imageFile: context.bindingData.name + \".jpg\",\n                    partitionKey: \"Functions\"\n                };\n                Object.assign(faceMapping, face.faceRectangle);\n                return faceMapping;\n            });\n        })\n        .catch((error) => context.log(error))\n        .finally(() => context.done());\n};",
            "package.json": "{\n  \"name\": \"FaceLocator-JavaScript\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"node-uuid\": \"^1.4.7\",\n    \"request-promise\": \"^3.0.0\"\n  }\n}\n",
            "sample.dat": "images/image.jpg"
        },
        "runtime": "1"
    },
    {
        "id": "GenericWebHook-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "genericJson",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GenericWebhookCSharp",
            "description": "$GenericWebhookCSharp_description",
            "name": "Generic Webhook",
            "language": "C#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ]
        },
        "files": {
            "run.csx": "#r \"Newtonsoft.Json\"\n\nusing System;\nusing System.Net;\nusing Newtonsoft.Json;\n\npublic static async Task<object> Run(HttpRequestMessage req, TraceWriter log)\r\n{\r\n    log.Info($\"Webhook was triggered!\");\r\n\r\n    string jsonContent = await req.Content.ReadAsStringAsync();\r\n    dynamic data = JsonConvert.DeserializeObject(jsonContent);\r\n\r\n    if (data.first == null || data.last == null)\r\n    {\r\n        return req.CreateResponse(HttpStatusCode.BadRequest, new\r\n        {\r\n            error = \"Please pass first/last properties in the input object\"\r\n        });\r\n    }\r\n\r\n    return req.CreateResponse(HttpStatusCode.OK, new\r\n    {\r\n        greeting = $\"Hello {data.first} {data.last}!\"\r\n    });\r\n}\n",
            "sample.dat": "{\n    \"first\": \"Azure\",\n    \"last\": \"Functions\"\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "GenericWebHook-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "genericJson",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GenericWebhookFSharp",
            "description": "$GenericWebhookFSharp_description",
            "name": "Generic Webhook",
            "language": "F#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ]
        },
        "files": {
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Newtonsoft.Json\"\n\nopen System.Net\nopen System.Net.Http\nopen Newtonsoft.Json\n\ntype Name = {\n    First: string\n    Last: string\n}\n\ntype Greeting = {\n    Greeting: string\n}\n\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\n    async {\n        log.Info(\"Webhook was triggered!\")\n        let! jsonContent = req.Content.ReadAsStringAsync() |> Async.AwaitTask\n\n        try\n            let name = JsonConvert.DeserializeObject<Name>(jsonContent)\n            return req.CreateResponse(HttpStatusCode.OK, \n                { Greeting = sprintf \"Hello %s %s!\" name.First name.Last })\n        with _ ->\n            return req.CreateResponse(HttpStatusCode.BadRequest)\n    } |> Async.StartAsTask\n",
            "sample.dat": "{\n    \"first\": \"Azure\",\n    \"last\": \"Functions\"\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "GenericWebHook-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "genericJson",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GenericWebhookJS",
            "description": "$GenericWebhookNodeJS_description",
            "name": "Generic Webhook",
            "language": "JavaScript",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, data) {\n    context.log('Webhook was triggered!');\n\n    // Check if we got first/last properties\n    if('first' in data && 'last' in data) {\n        context.res = {\n            body: { greeting: 'Hello ' + data.first + ' ' + data.last + '!'}\n        };\n    }\n    else {\n        context.res = {\n            status: 400,\n            body: { error: 'Please pass first/last properties in the input object'}\n        };\n    }\n\n    context.done();\n}\n",
            "sample.dat": "{\n    \"first\": \"Azure\",\n    \"last\": \"Functions\"\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "GenericWebHook-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "genericJson",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GenericWebhookTS",
            "description": "$GenericWebhookNodeTS_description",
            "name": "Generic Webhook",
            "language": "TypeScript",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_experimental"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, data: IData): void {\n    context.log(\"Webhook was triggered!\");\n\n    // check if we got first/last properties\n    if (\"first\" in data && \"last\" in data) {\n        context.res = {\n            body: { greeting: `Hello ${data.first} ${data.last}!` }\n        };\n    } else {\n        context.res = {\n            status: 400,\n            body: { error: \"Please pass first/last properties in the input object\" }\n        };\n    }\n\n    context.done();\n}\n\ninterface IData {\n    first: string;\n    last: string;\n}\n\n",
            "sample.dat": "{\n    \"first\": \"Azure\",\n    \"last\": \"Functions\"\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "GitHubCommenter-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "github",
                    "name": "payload"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "GitHubCommenterCSharp",
            "description": "$CSharp_description",
            "name": "GitHub Commenter",
            "language": "C#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_samples"
            ]
        },
        "files": {
            "run.csx": "// Please follow the link https://developer.github.com/v3/oauth/ to get information on GitHub authentication\n\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\n\npublic static async Task Run(dynamic payload, TraceWriter log)\r\n{\r\n    if (payload.action != \"opened\")\r\n    {\r\n        return;\r\n    }\r\n\r\n    string comment = \"{ \\\"body\\\": \\\"Thank you for your contribution, We will get to it shortly\\\" }\";\r\n    string label = \"[ \\\"bug\\\" ]\";\r\n\r\n    if (payload.issue != null)\r\n    {\r\n        log.Info($\"{payload.issue.user.login} posted an issue #{payload.issue.number}:{payload.issue.title}\");\r\n\r\n        //Post a comment \r\n        await SendGitHubRequest(payload.issue.comments_url.ToString(), comment);\r\n\r\n        //Add a label\r\n        await SendGitHubRequest($\"{payload.issue.url.ToString()}/labels\", label);\r\n    }\r\n\r\n    if (payload.pull_request != null)\r\n    {\r\n        log.Info($\"{payload.pull_request.user.login} submitted pull request #{payload.pull_request.number}:{payload.pull_request.title}\");\r\n\r\n        // posting a comment\r\n        await SendGitHubRequest(payload.pull_request.comments_url.ToString(), comment);\r\n    }\r\n}\r\n\r\npublic static async Task SendGitHubRequest(string url, string requestBody)\r\n{\r\n    using (var client = new HttpClient())\r\n    {\r\n        client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"username\", \"version\"));\r\n\r\n        // Add the GITHUB_CREDENTIALS as an app setting, Value for the app setting is a base64 encoded string in the following format\r\n        // \"Username:Password\" or \"Username:PersonalAccessToken\"\r\n        // Please follow the link https://developer.github.com/v3/oauth/ to get more information on GitHub authentication \r\n        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Basic\", Environment.GetEnvironmentVariable(\"GITHUB_CREDENTIALS\"));\r\n        var content = new StringContent(requestBody, Encoding.UTF8, \"application/json\");\r\n        await client.PostAsync(url, content);\r\n    }\r\n}\n",
            "sample.dat": "{\n  \"action\": \"opened\",\n  \"issue\": {\n    \"url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>\",\n    \"comments_url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>/comments\",    \n    \"title\": \"issue title\",\n    \"user\": {\n      \"login\": \"<USER>\"\n    },    \n    \"body\": \"issue description\"\n  }  \n}"
        },
        "runtime": "1"
    },
    {
        "id": "GitHubCommenter-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "github",
                    "name": "payload"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "GitHubCommenterFSharp",
            "description": "$GitHubCommenterFSharp_description",
            "name": "GitHub Commenter",
            "language": "F#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_samples"
            ]
        },
        "files": {
            "run.fsx": "// Please follow the link https://developer.github.com/v3/oauth/ to get information on GitHub authentication\n\n#r \"System.Net.Http\"\n#r \"Newtonsoft.Json\"\n\nopen System\nopen System.Net\nopen System.Net.Http\nopen System.Net.Http.Headers\nopen System.Text\nopen Newtonsoft.Json\nopen Newtonsoft.Json.Linq\n\nlet SendGitHubRequest (url: string) requestBody =\n    async {\n        use client = new HttpClient()\n\n        client.DefaultRequestHeaders.UserAgent.Add(\n            ProductInfoHeaderValue(\"username\", \"version\"))\n\n        // Add the GITHUB_CREDENTIALS as an app setting, Value for the app setting is a base64 encoded string in the following format\n        // \"Username:Password\" or \"Username:PersonalAccessToken\"\n        // Please follow the link https://developer.github.com/v3/oauth/ to get more information on GitHub authentication \n        client.DefaultRequestHeaders.Authorization <-\n            AuthenticationHeaderValue(\"Basic\",\n                Environment.GetEnvironmentVariable(\"GITHUB_CREDENTIALS\"))\n        use content =\n            new StringContent(requestBody, Encoding.UTF8, \"application/json\")\n        return! client.PostAsync(url, content) |> Async.AwaitTask\n    } |> Async.RunSynchronously\n\nlet rec hasProp (key: string list) (from: JObject) =\n    match from with\n    | null -> false\n    | _ ->\n        let x = from.[key.Head]\n        match x with\n        | null -> false\n        | _ ->\n            match key with\n            | [_] -> true\n            | _::tl -> hasProp tl (x.Value<JObject>())\n            | [] -> false\n\nlet rec prop<'T> (key: string list) (def: 'T) (from: JObject) =\n    match from with\n    | null -> def\n    | _ ->\n        let x = from.[key.Head]\n        match x with\n        | null -> def\n        | _ ->\n            match key with\n            | [_] -> x.Value<'T>()\n            | _::tl ->\n                prop<'T> tl def (x.Value<JObject>())\n            | [] -> def\n\nlet Run(payload: string, log: TraceWriter) =\n    let comment = \"{ \\\"body\\\": \\\"Thank you for your contribution, We will get to it shortly\\\" }\";\n    let label = \"[ \\\"bug\\\" ]\";\n\n    let json = JObject.Parse(payload)\n    if json |> prop [\"action\"] \"none\" = \"opened\" then\n        if hasProp [\"issue\"] json then\n            log.Info(\n                sprintf \"%s posted an issue #%d: %s\"\n                    (prop [\"issue\"; \"user\"; \"login\"] \"unknown user\" json)\n                    (prop [\"issue\"; \"number\"] 0 json)\n                    (prop [\"issue\"; \"title\"] \"unknown title\" json)\n                    )\n            SendGitHubRequest (prop [\"issue\"; \"comments_url\"] \"\" json) comment\n                |> ignore\n            SendGitHubRequest\n                (sprintf \"%s/labels\" (prop [\"issue\"; \"url\"] \"\" json)) label\n                |> ignore\n\n        if hasProp [\"pull_request\"] json then\n            log.Info(\n                sprintf \"%s submitted pull request #%d: %s\"\n                    (prop [\"pull_request\"; \"user\"; \"login\"] \"unknown user\" json)\n                    (prop [\"pull_request\"; \"number\"] 0 json)\n                    (prop [\"pull_request\"; \"title\"] \"unknown title\" json)\n                    )\n            SendGitHubRequest\n                (prop [\"pull_request\"; \"comments_url\"] \"\" json) comment\n                |> ignore\n",
            "sample.dat": "{\n  \"action\": \"opened\",\n  \"issue\": {\n    \"url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>\",\n    \"comments_url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>/comments\",    \n    \"title\": \"issue title\",\n    \"user\": {\n      \"login\": \"<USER>\"\n    },    \n    \"body\": \"issue description\"\n  }  \n}"
        },
        "runtime": "1"
    },
    {
        "id": "GitHubCommenter-JavaScript",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "github",
                    "name": "payload"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "GitHubCommenterJS",
            "description": "$GitHubCommenterNodeJS_description",
            "name": "GitHub Commenter",
            "language": "JavaScript",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_samples"
            ]
        },
        "files": {
            "index.js": "// Setup\n// 1) Go to Function app settings -> App Service settings -> Tools -> Console\n//    Enter the following commands: \n//    > cd <functionName>\n//    > npm install\n// 2) Add the GITHUB_CREDENTIALS as an app setting, Value for the app setting is a base64 encoded string in the following format\n//    \"Username:Password\" or \"Username:PersonalAccessToken\"\n//     Please follow the link https://developer.github.com/v3/oauth/ to get more information on GitHub authentication\nmodule.exports = function (context, payload) {\n    if (payload.action != \"opened\") {\n        context.done();\n        return;\n    }\n\n    var comment = { \"body\": \"Thank you for your contribution, We will get to it shortly\" };\n    var label = [\"bug\"];\n\n    if (payload.issue) {\n        context.log(payload.issue.user.login, \":posted issue #\", payload.issue.number, \":\", payload.issue.title);\n\n        //Post a comment \n        SendGitHubRequest(payload.issue.comments_url, comment, context);\n\n        //Add a label\n        SendGitHubRequest(payload.issue.url + \"/labels\", label, context);\n    }\n\n    if (payload.pull_request) {\n        context.log(payload.pull_request.user.login, \":submitted pull request #\", payload.pull_request.number, \":\", payload.pull_request.title);\n\n        // posting a comment\n        SendGitHubRequest(payload.pull_request.comments_url, comment, context);\n    }\n\n    context.done();\n};\n\nfunction SendGitHubRequest(url, requestBody, context) {\n\n    var request = require('request');\n    var githubCred = 'Basic ' + process.env.GITHUB_CREDENTIALS;\n    request({\n        url: url,\n        method: 'POST',\n        headers: {\n            'User-Agent': '<username>',\n            'Authorization': githubCred\n        },\n        json: requestBody\n    }, function (error, response, body) {\n        if (error) {\n            context.log(error);\n        } else {\n            context.log(response.statusCode, body);\n        }\n    });\n}",
            "package.json": "{\n  \"name\": \"GitHubCommenter-JavaScript\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"request\": \"^2.72.0\"\n  }\n}\n",
            "sample.dat": "{\n  \"action\": \"opened\",\n  \"issue\": {\n    \"url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>\",\n    \"comments_url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>/comments\",    \n    \"title\": \"issue title\",\n    \"user\": {\n      \"login\": \"<USER>\"\n    },    \n    \"body\": \"issue description\"\n  }  \n}"
        },
        "runtime": "1"
    },
    {
        "id": "GitHubWebHook-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "github",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GithubWebhookCSharp",
            "description": "$GithubWebhookCSharp_description",
            "name": "GitHub Webhook",
            "language": "C#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ]
        },
        "files": {
            "run.csx": "using System.Net;\n\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, TraceWriter log)\r\n{\r\n    log.Info(\"C# HTTP trigger function processed a request.\");\r\n\r\n    // Get request body\r\n    dynamic data = await req.Content.ReadAsAsync<object>();\r\n\r\n    // Extract github comment from request body\r\n    string gitHubComment = data?.comment?.body;\r\n\r\n    return req.CreateResponse(HttpStatusCode.OK, \"From Github:\" + gitHubComment);\r\n}\n",
            "sample.dat": "{\n    \"comment\": {\n        \"body\": \"This is a comment on a GitHub issue\"\n    }\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "GitHubWebHook-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "github",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GithubWebhookFSharp",
            "description": "$GithubWebhookFSharp_description",
            "name": "GitHub Webhook",
            "language": "F#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ]
        },
        "files": {
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Newtonsoft.Json\"\n\nopen System.Net\nopen System.Net.Http\nopen Newtonsoft.Json\n\ntype Body = {\n    body: string\n}\n\ntype Comment = {\n    comment: Body\n}\n\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\n    async {\n        log.Info(sprintf \"F# HTTP trigger function processed a request.\")\n\n        let! body = req.Content.ReadAsStringAsync() |> Async.AwaitTask\n        let data = JsonConvert.DeserializeObject<Comment>(body)\n        let comment = data.comment.body\n\n        if comment = null then\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"No comment data\")\n        else\n            return req.CreateResponse(HttpStatusCode.OK, \"From Github: \" + comment)\n    } |> Async.StartAsTask\n",
            "sample.dat": "{\n    \"comment\": {\n        \"body\": \"This is a comment on a GitHub issue\"\n    }\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "GitHubWebHook-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "github",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GithubWebhookJS",
            "description": "$GithubWebhookNodeJS_description",
            "name": "GitHub Webhook",
            "language": "JavaScript",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ]
        },
        "files": {
            "index.js": "// Please visit http://go.microsoft.com/fwlink/?LinkID=761099&clcid=0x409 for more information on settting up Github Webhooks\nmodule.exports = function (context, data) {\n    context.log('GitHub Webhook triggered!', data.comment.body);\n    context.res = { body: 'New GitHub comment: ' + data.comment.body };\n    context.done();\n};",
            "sample.dat": "{\n    \"comment\": {\n        \"body\": \"This is a comment on a GitHub issue\"\n    }\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "GitHubWebHook-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "webHookType": "github",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "GithubWebhookTS",
            "description": "$GithubWebhookNodeTS_description",
            "name": "GitHub Webhook",
            "language": "TypeScript",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_experimental"
            ]
        },
        "files": {
            "index.ts": "/*\n Please visit http://go.microsoft.com/fwlink/?LinkID=761099&clcid=0x409\n     for more information on settting up Github Webhooks\n*/\nexport function run(context: any, data: any): any {\n    context.log(\"GitHub Webhook triggered!\", data.comment.body);\n    context.res = { body: `New GitHub comment: ${data.comment.body}` };\n    context.done();\n};",
            "sample.dat": "{\n    \"comment\": {\n        \"body\": \"This is a comment on a GitHub issue\"\n    }\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "HttpGET(CRUD)-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "get"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "inTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "in"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpGET-CRUD-CSharp",
            "description": "$HttpGETCRUDC_description",
            "name": "HttpGET(CRUD)",
            "language": "C#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "run.csx": "#r \"Microsoft.WindowsAzure.Storage\"\n\nusing System.Net;\nusing Microsoft.WindowsAzure.Storage.Table;\n\npublic static HttpResponseMessage Run(HttpRequestMessage req, IQueryable<Person> inTable, TraceWriter log)\r\n{\r\n    var query = from person in inTable select person;\r\n    foreach (Person person in query)\r\n    {\r\n        log.Info($\"Name:{person.Name}\");\r\n    }\r\n    return req.CreateResponse(HttpStatusCode.OK, inTable.ToList());\r\n}\r\n\r\npublic class Person : TableEntity\r\n{\r\n    public string Name { get; set; }\r\n}\n",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "HttpGET(CRUD)-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "get"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "inTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "in"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpGET-CRUD-FSharp",
            "description": "$HttpGETCRUDFSharp_description",
            "name": "HttpGET(CRUD)",
            "language": "F#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Microsoft.WindowsAzure.Storage\"\n\nopen System.Linq\nopen System.Net\nopen System.Net.Http\nopen Microsoft.WindowsAzure.Storage.Table\n\ntype Person() =\n    inherit TableEntity()\n    member val Name: string = null with get, set\n\nlet Run(req: HttpRequestMessage, inTable: IQueryable<Person>, log: TraceWriter) =\n    let people =\n        query {\n            for person in inTable do\n            select person\n        }\n        |> Seq.map (fun person -> sprintf \"\\\"Name\\\": \\\"%s\\\"\" person.Name)\n        |> String.concat \",\"\n\n    req.CreateResponse(HttpStatusCode.OK, sprintf \"{%s}\" people)\n",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "HttpGET(CRUD)-JavaScript",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "get"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "inTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "in"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpGET-CRUD-JS",
            "description": "$HttpGETCRUDNodeJS_description",
            "name": "HttpGET(CRUD)",
            "language": "JavaScript",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, req, intable) {\n    context.log(\"Retrieved records:\", intable);\n    context.res = {\n        status: 200,\n        body: intable\n    };\n    context.done();\n};",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "HttpGET(CRUD)-PHP",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "get"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "inTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "in"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpGET-CRUD-PHP",
            "description": "$HttpGETCRUDPHP_description",
            "name": "HttpGET(CRUD)",
            "language": "Php",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "run.php": "<?php\n$inTable = json_decode(file_get_contents(getenv('inTable')));\nfile_put_contents(getenv('res'), json_encode($inTable));\n?>",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "HttpPOST(CRUD)-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpPOST-CRUD-CSharp",
            "description": "$HttpPOSTCRUDCSharp_description",
            "name": "HttpPOST(CRUD)",
            "language": "C#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "run.csx": "#r \"Microsoft.WindowsAzure.Storage\"\n\nusing System.Net;\nusing Microsoft.WindowsAzure.Storage.Table;\n\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, ICollector<Person> outTable, TraceWriter log)\r\n{\r\n    dynamic data = await req.Content.ReadAsAsync<object>();\r\n    string name = data?.name;\r\n\r\n    if (name == null)\r\n    {\r\n        return req.CreateResponse(HttpStatusCode.BadRequest, \"Please pass a name in the request body\");\r\n    }\r\n\r\n    outTable.Add(new Person()\r\n    {\r\n        PartitionKey = \"Functions\",\r\n        RowKey = Guid.NewGuid().ToString(),\r\n        Name = name\r\n    });\r\n    return req.CreateResponse(HttpStatusCode.Created);\r\n}\r\n\r\npublic class Person : TableEntity\r\n{\r\n    public string Name { get; set; }\r\n}\n",
            "sample.dat": "{\n    \"name\": \"Azure\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpPOST(CRUD)-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpPOST-CRUD-FSharp",
            "description": "$HttpPOSTCRUDFSharp_description",
            "name": "HttpPOST(CRUD)",
            "language": "F#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Microsoft.WindowsAzure.Storage\"\n#r \"Newtonsoft.Json\"\n\nopen System\nopen System.Net\nopen System.Net.Http\nopen Microsoft.WindowsAzure.Storage.Table\nopen Newtonsoft.Json\nopen Newtonsoft.Json.Linq\n\ntype Person() =\n    inherit TableEntity()\n    member val Name: string = null with get, set\n\nlet Run(req: HttpRequestMessage, outTable: ICollector<Person>, log: TraceWriter) =\n    async {\n        let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\n        let json = JObject.Parse(data)\n        let nameJ = json.[\"name\"]\n\n        if nameJ <> null then\n            let name = nameJ.Value<string>()\n            let person = Person()\n            person.PartitionKey <- \"Functions\"\n            person.RowKey <- Guid.NewGuid().ToString()\n            person.Name <- name\n            outTable.Add(person)\n\n            return req.CreateResponse(HttpStatusCode.Created)\n        else\n            return req.CreateResponse(HttpStatusCode.BadRequest,\n                \"Please pass a name in the request body\")\n    } |> Async.StartAsTask\n",
            "sample.dat": "{\n    \"name\": \"Azure\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpPOST(CRUD)-JavaScript",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "person",
                    "partitionKey": "functions",
                    "rowKey": "{rand-guid}",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpPOST-CRUD-JS",
            "description": "$HttpPOSTCRUDNodeJS_description",
            "name": "HttpPOST(CRUD)",
            "language": "JavaScript",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, req) {\n    var statusCode = 400;\n    var responseBody = \"Invalid request object\";\n\n    if (typeof req.body != 'undefined' && typeof req.body == 'object') {\n        statusCode = 201;\n        context.bindings.outTable = req.body;\n        responseBody = \"Table Storage Created\";\n    }\n\n    context.res = {\n        status: statusCode,\n        body: responseBody\n    };\n\n    context.done();\n};",
            "sample.dat": "{\n    \"name\": \"Azure\"    \n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpPOST(CRUD)Queue-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "queue",
                    "name": "personItem",
                    "queueName": "person",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpPOST-CRUD-Queue-FSharp",
            "description": "$HttpPOST(CRUD)Queue-FSharp_description",
            "name": "HttpPOST(CRUD)Queue",
            "language": "F#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "queueName",
                "connection"
            ]
        },
        "files": {
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Microsoft.WindowsAzure.Storage\"\n#r \"Newtonsoft.Json\"\n\nopen System\nopen System.Net\nopen System.Net.Http\nopen Newtonsoft.Json\nopen Newtonsoft.Json.Linq\nopen Microsoft.WindowsAzure.Storage\nopen Microsoft.WindowsAzure.Storage.Queue\n\ntype Person() =\n    member val id: Guid = Guid.NewGuid() with get    \n    member val firstName: string = null with get, set    \n    member val lastName: string = null with get, set    \n    member val address: string = null with get, set    \n\nlet inline getValue (value:JToken) = \n    match isNull value with\n    | false -> value.Value<string>()  \n    | true -> \"\"\n\nlet hydrate data = \n    let json = JObject.Parse(data)\n    let person = Person()\n    person.firstName <- getValue json.[\"firstName\"]\n    person.lastName <- getValue json.[\"lastName\"] \n    person.address <- getValue json.[\"address\"] \n    person\n\nlet isValid (person:Person) =\n    [person.firstName; person.lastName; person.address]\n    |> List.forall (not << String.IsNullOrEmpty)\n\nlet Run(req: HttpRequestMessage, personItem:string byref) =\n    let data = req.Content.ReadAsStringAsync().Result\n    let person = hydrate data\n    match isValid person with\n    | true -> \n        let queueMessage = person |> JsonConvert.SerializeObject\n        personItem <- queueMessage\n        req.CreateResponse(HttpStatusCode.Created)\n    | false ->\n        req.CreateResponse(HttpStatusCode.BadRequest, \"Please pass all of the values in the request body\")\n",
            "sample.dat": "{\n  \"firstName\": \"Test\",\n  \"lastName\": \"Person\",\n  \"address\": \"123 Main Street\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpPUT(CRUD)-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "person",
                    "methods": [
                        "put"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpPUT-CRUD-CSharp",
            "description": "$HttpPUTCRUDC_description",
            "name": "HttpPUT(CRUD)",
            "language": "C#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "run.csx": "#r \"Microsoft.WindowsAzure.Storage\"\n\nusing System.Net;\nusing Microsoft.WindowsAzure.Storage.Table;\n\npublic static HttpResponseMessage Run(Person person, CloudTable outTable, TraceWriter log)\r\n{\r\n    if (string.IsNullOrEmpty(person.Name))\r\n    {\r\n        return new HttpResponseMessage(HttpStatusCode.BadRequest)\r\n        {\r\n            Content = new StringContent(\"A non-empty Name must be specified.\")\r\n        };\r\n    };\r\n\r\n    log.Info($\"PersonName={person.Name}\");\r\n\r\n    TableOperation updateOperation = TableOperation.InsertOrReplace(person);\r\n    TableResult result = outTable.Execute(updateOperation);\r\n    return new HttpResponseMessage((HttpStatusCode)result.HttpStatusCode);\r\n}\r\n\r\npublic class Person : TableEntity\r\n{\r\n    public string Name { get; set; }\r\n}\n",
            "sample.dat": "{\n    \"name\": \"Azure\",\n    \"partitionKey\": \"Functions\",\n    \"rowKey\" :  \"<RowKey>\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpPUT(CRUD)-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "put"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                },
                {
                    "type": "table",
                    "name": "outTable",
                    "tableName": "person",
                    "connection": "",
                    "direction": "out"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "HttpPUT-CRUD-FSharp",
            "description": "$HttpPUTCRUDFSharp_description",
            "name": "HttpPUT(CRUD)",
            "language": "F#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "tableName",
                "connection"
            ]
        },
        "files": {
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Microsoft.WindowsAzure.Storage\"\n#r \"Newtonsoft.Json\"\n\nopen System\nopen System.Net\nopen System.Net.Http\nopen Microsoft.WindowsAzure.Storage.Table\nopen Newtonsoft.Json\nopen Newtonsoft.Json.Linq\n\ntype Person(name, partitionKey, rowKey) =\n    inherit TableEntity(partitionKey, rowKey)\n    member val Name: string = name with get, set\n\nlet Run(req: HttpRequestMessage, outTable: CloudTable, log: TraceWriter) =\n    async {\n        let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\n        let json = JObject.Parse(data)\n        let nameJ = json.[\"name\"]\n        let partitionKeyJ = json.[\"partitionKey\"]\n        let rowKeyJ = json.[\"rowKey\"]\n\n        if nameJ = null || partitionKeyJ = null || rowKeyJ = null then\n            let response = new HttpResponseMessage(HttpStatusCode.BadRequest)\n            response.Content <-\n                new StringContent(\"A non-empty name, partitionKey, and rowKey must be specified.\")\n            return response\n        else\n            let person =\n                Person(\n                    nameJ.Value<string>(),\n                    partitionKeyJ.Value<string>(),\n                    rowKeyJ.Value<string>())\n            log.Info(sprintf \"PersonName=%s\" person.Name)\n            let updateOperation = TableOperation.InsertOrReplace(person)\n            let result = outTable.Execute(updateOperation)\n            return new HttpResponseMessage(enum<HttpStatusCode>(result.HttpStatusCode))\n    } |> Async.RunSynchronously\n",
            "sample.dat": "{\n    \"name\": \"Azure\",\n    \"partitionKey\": \"Functions\",\n    \"rowKey\" :  \"<RowKey>\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTrigger-Batch",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in"
                },
                {
                    "name": "res",
                    "type": "http",
                    "direction": "out"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerBatch",
            "description": "$HttpTriggerBatch_description",
            "name": "HttpTrigger",
            "language": "Batch",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "run.bat": "echo OFF\n\nIF DEFINED req_query_name (\n\techo Hello %req_query_name%! > %res%\n) ELSE (\n\techo Please pass a name on the query string > %res%\n)"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in"
                },
                {
                    "name": "$return",
                    "type": "http",
                    "direction": "out"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerCSharp",
            "description": "$HttpTriggerCSharp_description",
            "name": "HttpTrigger",
            "language": "C#",
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "readme.md": "# HttpTrigger - C<span>#</span>\n\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\n\n## How it works\n\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\n\n## Learn more\n\n<TODO> Documentation",
            "run.csx": "using System.Net;\n\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, TraceWriter log)\r\n{\r\n    log.Info(\"C# HTTP trigger function processed a request.\");\r\n\r\n    // parse query parameter\r\n    string name = req.GetQueryNameValuePairs()\r\n        .FirstOrDefault(q => string.Compare(q.Key, \"name\", true) == 0)\r\n        .Value;\r\n\r\n    // Get request body\r\n    dynamic data = await req.Content.ReadAsAsync<object>();\r\n\r\n    // Set name to query string or body data\r\n    name = name ?? data?.name;\r\n\r\n    return name == null\r\n        ? req.CreateResponse(HttpStatusCode.BadRequest, \"Please pass a name on the query string or in the request body\")\r\n        : req.CreateResponse(HttpStatusCode.OK, \"Hello \" + name);\r\n}\n",
            "sample.dat": "{\n    \"name\": \"Azure\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in"
                },
                {
                    "name": "res",
                    "type": "http",
                    "direction": "out"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerFSharp",
            "description": "$HttpTriggerFSharp_description",
            "name": "HttpTrigger",
            "language": "F#",
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "project.json": "{\n  \"frameworks\": {\n    \"net46\":{\n      \"dependencies\": {\n        \"FSharp.Interop.Dynamic\": \"3.0.0\"\n      }\n    }\n  }\n}\n",
            "readme.md": "# HttpTrigger - F<span>#</span>\n\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\n\n## How it works\n\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\n\n## Learn more\n\n<TODO> Documentation",
            "run.fsx": "#r \"System.Net.Http\"\n#r \"Newtonsoft.Json\"\n\nopen System.Net\nopen System.Net.Http\nopen Newtonsoft.Json\n\ntype Named = {\n    name: string\n}\n\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\n    async {\n        log.Info(sprintf \n            \"F# HTTP trigger function processed a request.\")\n\n        // Set name to query string\n        let name =\n            req.GetQueryNameValuePairs()\n            |> Seq.tryFind (fun q -> q.Key = \"name\")\n\n        match name with\n        | Some x ->\n            return req.CreateResponse(HttpStatusCode.OK, \"Hello \" + x.Value);\n        | None ->\n            let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\n\n            if not (String.IsNullOrEmpty(data)) then\n                let named = JsonConvert.DeserializeObject<Named>(data)\n                return req.CreateResponse(HttpStatusCode.OK, \"Hello \" + named.name);\n            else\n                return req.CreateResponse(HttpStatusCode.BadRequest, \"Specify a Name value\");\n    } |> Async.RunSynchronously\n",
            "sample.dat": "{\n    \"name\": \"Azure\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerJS",
            "description": "$HttpTriggerNodeJS_description",
            "name": "HttpTrigger",
            "language": "JavaScript",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, req) {\n    context.log('JavaScript HTTP trigger function processed a request.');\n\n    if (req.query.name || (req.body && req.body.name)) {\n        context.res = {\n            // status: 200, /* Defaults to 200 */\n            body: \"Hello \" + (req.query.name || req.body.name)\n        };\n    }\n    else {\n        context.res = {\n            status: 400,\n            body: \"Please pass a name on the query string or in the request body\"\n        };\n    }\n    context.done();\n};",
            "sample.dat": "{\n    \"name\": \"Azure\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTrigger-Powershell",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in"
                },
                {
                    "name": "res",
                    "type": "http",
                    "direction": "out"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerPowerShell",
            "description": "$HttpTriggerPowerShell_description",
            "name": "HttpTrigger",
            "language": "PowerShell",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "readme.md": "# HttpTrigger - PowerShell\n\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\n\n## How it works\n\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\n\n## Learn more\n\n<TODO> Documentation",
            "run.ps1": "# POST method: $req\n$requestBody = Get-Content $req -Raw | ConvertFrom-Json\n$name = $requestBody.name\n\n# GET method: each querystring parameter is its own variable\nif ($req_query_name) \n{\n    $name = $req_query_name \n}\n\nOut-File -Encoding Ascii -FilePath $res -inputObject \"Hello $name\"\n",
            "sample.dat": "{\n    \"name\": \"Azure\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTrigger-Python",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerPython3",
            "description": "$HttpTriggerPython_description",
            "name": "HttpTrigger",
            "language": "Python",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "run.py": "import os\nimport json\n\npostreqdata = json.loads(open(os.environ['req']).read())\nresponse = open(os.environ['res'], 'w')\nresponse.write(\"hello world from \"+postreqdata['name'])\nresponse.close()",
            "sample.dat": "{\n    \"name\": \"Python Function App\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req"
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerTS",
            "description": "$HttpTriggerNodeTS_description",
            "name": "HttpTrigger",
            "language": "TypeScript",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, req: any): void {\n    context.log(\"TypeScript HTTP trigger function processed a request.\");\n\n    if (req.query.name || (req.body && req.body.name)) {\n        context.res = {\n            // status: 200, /* Defaults to 200 */\n            body: {\n                message: `Hello ${(req.query.name || req.body.name)}`\n            }\n        };\n    } else {\n        context.res = {\n            status: 400,\n            body: \"Please pass a name on the query string or in the request body\"\n        };\n    }\n    context.done();\n};",
            "sample.dat": "{\n    \"name\": \"Azure\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTriggerWithParameters-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in",
                    "route": "HttpTriggerCSharp/name/{name}",
                    "methods": [
                        "get"
                    ]
                },
                {
                    "name": "$return",
                    "type": "http",
                    "direction": "out"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerCSharpWithParameters",
            "description": "$HttpTriggerCSharpWithParameters_description",
            "name": "HttpTriggerWithParameters",
            "language": "C#",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "readme.md": "# HttpTrigger - C<span>#</span>\n\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\n\n## How it works\n\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\n\n## Learn more\n\n<TODO> Documentation",
            "run.csx": "using System.Net;\n\npublic static HttpResponseMessage Run(HttpRequestMessage req, string name, TraceWriter log)\r\n{\r\n    log.Info(\"C# HTTP trigger function processed a request.\");\r\n\r\n    // Fetching the name from the path parameter in the request URL\r\n    return req.CreateResponse(HttpStatusCode.OK, \"Hello \" + name);\r\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "HttpTriggerWithParameters-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "route": "HttpTriggerJS/name/{name}",
                    "methods": [
                        "get"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "HttpTriggerWithParametersJS",
            "description": "$HttpTriggerWithParametersNodeJS_description",
            "name": "HttpTriggerWithParameters",
            "language": "JavaScript",
            "trigger": "HttpTrigger",
            "category": [
                "$temp_category_core",
                "$temp_category_api"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, req) {\n    context.log('JavaScript HTTP trigger function processed a request.');\n    context.res = {\n        // status: 200, /* Defaults to 200 */\n        body: \"Hello \" + req.params.name\n    };\n    context.done();\n};"
        },
        "runtime": "1"
    },
    {
        "id": "ImageResizer-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "path": "sample-images/{name}",
                    "type": "blobTrigger",
                    "name": "image",
                    "direction": "in",
                    "connection": ""
                },
                {
                    "path": "sample-images-sm/{name}",
                    "type": "blob",
                    "name": "imageSmall",
                    "direction": "out",
                    "connection": ""
                },
                {
                    "path": "sample-images-md/{name}",
                    "type": "blob",
                    "name": "imageMedium",
                    "direction": "out",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "Image resize",
            "description": "$ImageResizerCSharp_description",
            "defaultFunctionName": "ResizeImageCSharp",
            "language": "C#",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "project.json": "{\n  \"frameworks\": {\n    \"net46\":{\n      \"dependencies\": {\n        \"ImageResizer\": \"4.0.5\"\n      }\n    }\n  }\n}\n",
            "readme.md": "# Image resizing with a blob trigger - C<span>#</span>\n\nUsing a blob trigger and the [ImageResizer](https://www.nuget.org/packages/ImageResizer/) nuget package, you can create a function that resizes new images when they are added to a container. This sample shows how to use a blob trigger to trigger the function and how to use output blobs with the same input blob name.\n\n## How it works\n\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\n\nThe sample uses different containers for the different image sizes, but you could instead use the same container and rename the image file instead. For instance, the blob path `sample-images/md-{name}` would prepend \"md\" to the input blob name.\n\n",
            "run.csx": "using ImageResizer;\n \npublic static void Run(\n    Stream image,                           // input blob, large size\n    Stream imageSmall, Stream imageMedium)  // output blobs\n{\n    var imageBuilder = ImageResizer.ImageBuilder.Current;\n    var size = imageDimensionsTable[ImageSize.Small];\n\n    imageBuilder.Build(\n        image, imageSmall, \n        new ResizeSettings(size.Item1, size.Item2, FitMode.Max, null), false);\n\n    image.Position = 0;\n    size = imageDimensionsTable[ImageSize.Medium];\n\n    imageBuilder.Build(\n        image, imageMedium,\n        new ResizeSettings(size.Item1, size.Item2, FitMode.Max, null), false);\n}\n\npublic enum ImageSize\n{\n    ExtraSmall, Small, Medium\n}\n\nprivate static Dictionary<ImageSize, Tuple<int, int>> imageDimensionsTable = new Dictionary<ImageSize, Tuple<int, int>>()\n{\n    { ImageSize.ExtraSmall, Tuple.Create(320, 200) },\n    { ImageSize.Small,      Tuple.Create(640, 400) },\n    { ImageSize.Medium,     Tuple.Create(800, 600) }\n};\n"
        },
        "runtime": "1"
    },
    {
        "id": "ImageResizer-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "path": "sample-images/{name}",
                    "type": "blobTrigger",
                    "name": "image",
                    "direction": "in",
                    "connection": ""
                },
                {
                    "path": "sample-images-sm/{name}",
                    "type": "blob",
                    "name": "imageSmall",
                    "direction": "out",
                    "connection": ""
                },
                {
                    "path": "sample-images-md/{name}",
                    "type": "blob",
                    "name": "imageMedium",
                    "direction": "out",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "Image resize",
            "description": "$ImageResizerFSharp_description",
            "defaultFunctionName": "ResizeImageFSharp",
            "language": "F#",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "path"
            ]
        },
        "files": {
            "project.json": "{\n  \"frameworks\": {\n    \"net46\":{\n      \"dependencies\": {\n        \"ImageResizer\": \"4.0.5\"\n      }\n    }\n  }\n}\n",
            "readme.md": "# Image resizing with a blob trigger - F<span>#</span>\n\nUsing a blob trigger and the [ImageResizer](https://www.nuget.org/packages/ImageResizer/) nuget package, you can create a function that resizes new images when they are added to a container. This sample shows how to use a blob trigger to trigger the function and how to use output blobs with the same input blob name.\n\n## How it works\n\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\n\nThe sample uses different containers for the different image sizes, but you could instead use the same container and rename the image file instead. For instance, the blob path `sample-images/md-{name}` would prepend \"md\" to the input blob name.\n\n",
            "run.fsx": "#r \"ImageResizer.dll\"\n#r \"System.Drawing.dll\"\n\nopen System.IO\nopen ImageResizer\n\nlet Run(image: Stream, imageSmall: Stream, imageMedium: Stream) =\n    let imageBuilder = ImageResizer.ImageBuilder.Current\n\n    imageBuilder.Build(\n        image, imageSmall, \n        ResizeSettings(320, 200, FitMode.Max, null), false)\n\n    image.Position <- int64 0\n\n    imageBuilder.Build(\n        image, imageMedium,\n        ResizeSettings(800, 600, FitMode.Max, null), false)\n"
        },
        "runtime": "1"
    },
    {
        "id": "ManualTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "manualTrigger",
                    "direction": "in",
                    "name": "input"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ManualTriggerCSharp",
            "description": "$ManualTriggerCSharp_description",
            "name": "ManualTrigger",
            "trigger": "ManualTrigger",
            "language": "C#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core"
            ]
        },
        "files": {
            "run.csx": "using System;\n\npublic static void Run(string input, TraceWriter log)\n{\n    log.Info($\"C# manually triggered function called with input: {input}\");\n}",
            "sample.dat": "Test Value"
        },
        "runtime": "1"
    },
    {
        "id": "ManualTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "manualTrigger",
                    "direction": "in",
                    "name": "input"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ManualTriggerFSharp",
            "description": "$ManualTriggerFSharp_description",
            "name": "ManualTrigger",
            "trigger": "ManualTrigger",
            "language": "F#",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core"
            ]
        },
        "files": {
            "run.fsx": "let Run(input: string, log: TraceWriter) =\n    log.Info(\n        sprintf \"F# manually triggered function called with input: %s\" input)\n",
            "sample.dat": "Test Value"
        },
        "runtime": "1"
    },
    {
        "id": "ManualTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "manualTrigger",
                    "direction": "in",
                    "name": "input"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ManualTriggerJS",
            "description": "$ManualTriggerNodeJS_description",
            "name": "ManualTrigger",
            "trigger": "ManualTrigger",
            "language": "JavaScript",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_core"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, input) {\n    context.log('JavaScript manually triggered function called with input:', input);\n    context.done();\n};",
            "sample.dat": "Test Value"
        },
        "runtime": "1"
    },
    {
        "id": "ManualTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "type": "manualTrigger",
                    "direction": "in",
                    "name": "input"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ManualTriggerTS",
            "description": "$ManualTriggerNodeTS_description",
            "name": "ManualTrigger",
            "trigger": "ManualTrigger",
            "language": "TypeScript",
            "enabledInTryMode": true,
            "category": [
                "$temp_category_experimental"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, input: any) {\n    context.log(`TypeScript manually triggered function called with input: ${input}`);\n    context.done();\n};",
            "sample.dat": "Test Value"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-Bash",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "inputMessage",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "samples-bash",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerBash",
            "description": "$QueueTriggerBash_description",
            "name": "QueueTrigger",
            "language": "Bash",
            "trigger": "QueueTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "run.sh": "inputMessage=$(<$inputMessage)\nprintf \"Bash script processed queue message: $inputMessage\"",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-Batch",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "inputMessage",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "samples-batch",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerBatch",
            "description": "$QueueTriggerBatch_description",
            "name": "QueueTrigger",
            "language": "Batch",
            "trigger": "QueueTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "run.bat": "echo OFF\nSET /p inputMessage=<%inputMessage%\necho Windows Batch script processed queue message '%inputMessage%'",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myQueueItem",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "myqueue-items",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerCSharp",
            "description": "$QueueTriggerCSharp_description",
            "name": "QueueTrigger",
            "language": "C#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "readme.md": "# QueueTrigger - C<span>#</span>\n\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\n\n## How it works\n\nFor a `QueueTrigger` to work, you must provide a queue name that defines the queue messages will be read from.\n\n## Learn more\n\n<TODO> Documentation",
            "run.csx": "using System;\n\npublic static void Run(string myQueueItem, TraceWriter log)\r\n{\r\n    log.Info($\"C# Queue trigger function processed: {myQueueItem}\");\r\n}\n",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "inputMessage",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "samples-fsharp",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerFSharp",
            "description": "$QueueTriggerFSharp_description",
            "name": "QueueTrigger",
            "language": "F#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "readme.md": "# QueueTrigger - F<span>#</span>\n\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using F#.\n\n## How it works\n\nFor a `QueueTrigger` to work, you must provide a queue name that defines the queue messages will be read from.\n\n## Learn more\n\n<TODO> Documentation",
            "run.fsx": "let Run(inputMessage: string, log: TraceWriter) =\n    log.Info(sprintf \"F# Queue trigger function processed: '%s'\" inputMessage)\n",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myQueueItem",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "js-queue-items",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerJS",
            "description": "$QueueTriggerNodeJS_description",
            "name": "QueueTrigger",
            "language": "JavaScript",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, myQueueItem) {\n    context.log('JavaScript queue trigger function processed work item', myQueueItem);\n    context.done();\n};",
            "readme.md": "# QueueTrigger - JavaScript\n\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\n\n## How it works\n\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\n\n## Learn more\n\n<TODO> Documentation",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-Php",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "inputMessage",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "samples-php",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerPHP",
            "description": "$QueueTriggerPHP_description",
            "name": "QueueTrigger",
            "language": "Php",
            "trigger": "QueueTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "run.php": "<?php\n  $inputMessage = file_get_contents(getenv('inputMessage'));\n  $inputMessage = rtrim($inputMessage, \"\\n\\r\");\n  fwrite(STDOUT, \"PHP script processed queue message '$inputMessage'\");\n?>",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-Powershell",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "triggerInput",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "samples-powershell",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerPowerShell",
            "description": "$QueueTriggerPowerShell_description",
            "name": "QueueTrigger",
            "language": "PowerShell",
            "trigger": "QueueTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "run.ps1": "$in = Get-Content $triggerInput\nWrite-Output \"PowerShell script processed queue message '$in'\"",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-Python",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "inputMessage",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "samples-python",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerPython",
            "description": "$QueueTriggerPython_description",
            "name": "QueueTrigger",
            "language": "Python",
            "trigger": "QueueTrigger",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "run.py": "import os\n\n# read the queue message and write to stdout\ninputMessage = open(os.environ['inputMessage']).read()\nmessage = \"Python script processed queue message '{0}'\".format(inputMessage)\nprint(message)",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "QueueTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myQueueItem",
                    "type": "queueTrigger",
                    "direction": "in",
                    "queueName": "ts-queue-items",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "QueueTriggerTS",
            "description": "$QueueTriggerNodeTS_description",
            "name": "QueueTrigger",
            "language": "TypeScript",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "connection",
                "queueName"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, item: any) {\n    context.log(`TypeScript queue trigger function processed work item: ${item}`);\n    context.done();\n};",
            "readme.md": "# QueueTrigger - TypeScript\n\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\n\n## How it works\n\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\n\n## Learn more\n\n<TODO> Documentation",
            "sample.dat": "sample queue data"
        },
        "runtime": "1"
    },
    {
        "id": "SasToken-CSharp",
        "function": {
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "input",
                    "type": "httpTrigger",
                    "direction": "in",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "name": "$return",
                    "type": "http",
                    "direction": "out"
                },
                {
                    "type": "blob",
                    "name": "blobDirectory",
                    "path": "{ContainerName}",
                    "connection": "",
                    "direction": "in"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "SasTokenCSharp",
            "description": "A C# function that generates a SAS token for Azure Storage for a given container and blob name",
            "name": "SAS Token Generator",
            "language": "C#",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel",
                "connection"
            ]
        },
        "files": {
            "readme.md": "# SAS Token Generator - C<span>#</span>\n\nAn HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container, blob, and permissions. A SAS token provides a secure way for client apps to access particular storage account resources, without giving them the full control of the storage access key.\n\n##Calling the function\n\nTo request a SAS token, send an HTTP post to your function URI, including the API key if you've specified one. The request body format is:\n\n- `ContainerName` - *required*. Name of container in storage account\n- `BlobName` - *optional*. Used to scope permissions to a particular blob\n- `Permission` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\n\n## How it works\n\nWhen you create a storage account, you get two storage access keys, which provide full control over the storage account contents. Since these keys are admin credentials, they should **never** be distributed with a client app. \n\nInstead, clients should use a shared access signature (SAS) for delegated access to storage resources. A SAS token, which is appended to a storage resource URI, provides access to only a particular resource for a limited period of time. A SAS token can be scoped to a blob or a container and specifies access permissions (such as read or write).\n\nA SAS token is usually generated server-side, using the account access key and the Azure Storage SDK. This sample shows how to use an Azure Function as a SAS token service. Web and mobile clients can call this function to request access to a particular container or blob. By default, the sample creates a token that expires after an hour, but this can be customized.\n\nIf the function will be called from a mobile client or a JavaScript web app, we recommend that you add authentication to your Function using [App Service Authentication/Authorization](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/). The API key is usually insufficent for security purposes since it can be discovered by sniffing traffic or decompiling the client app.\n\n## Learn more\n\n- [Authentication and authorization in Azure App Service](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/)\n- [Shared Access Signatures: Understanding the SAS Model](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)\n- [Create and use a SAS with Blob storage](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-2/)\n- [Delegating Access with a Shared Access Signature](https://msdn.microsoft.com/library/ee395415.aspx)\n- [Establishing a Stored Access Policy](https://msdn.microsoft.com/library/dn140257.aspx)\n",
            "run.csx": "// An HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container. \n// You can also optionally specify a particular blob name and access permissions. \n// To learn more, see https://github.com/Azure/azure-webjobs-sdk-templates/blob/master/Templates/SasToken-CSharp/readme.md\n\n// Request body format:\n// - `ContainerName` - *required*. Name of container in storage account\n// - `BlobName` - *optional*. Used to scope permissions to a particular blob\n// - `Permission` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. \n//    Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\n#r \"Microsoft.WindowsAzure.Storage\"\n\nusing System.Net;\nusing System.Configuration;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Blob;\n\npublic static HttpResponseMessage Run(Input input, CloudBlobDirectory blobDirectory, TraceWriter log)\n{\r\n    {\r\n        var permissions = SharedAccessBlobPermissions.Read; // default to read permissions\r\n\r\n        // if permission was supplied, check if it is a possible value\r\n        if (!string.IsNullOrWhiteSpace(input.Permission))\r\n        {\r\n            if (!Enum.TryParse(input.Permission, out permissions))\r\n            {\r\n                return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent(\"Invalid value for 'permissions'\") };\r\n            }\r\n        }\r\n\r\n        var container = blobDirectory.Container;\r\n        var sasToken = input.BlobName != null ?\r\n             GetBlobSasToken(container, input.BlobName, permissions) :\r\n             GetContainerSasToken(container, permissions);\r\n\r\n        return new HttpResponseMessage(HttpStatusCode.OK) { Content = new StringContent(sasToken) };\r\n    }\n\n        public class Input\r\n{\r\n    public string ContainerName { get; set; }\r\n    public string BlobName { get; set; }\r\n    public string Permission { get; set; }\r\n}\r\n\r\npublic static string GetBlobSasToken(CloudBlobContainer container, string blobName, SharedAccessBlobPermissions permissions, string policyName = null)\r\n{\r\n    string sasBlobToken;\r\n\r\n    // Get a reference to a blob within the container.\r\n    // Note that the blob may not exist yet, but a SAS can still be created for it.\r\n    CloudBlockBlob blob = container.GetBlockBlobReference(blobName);\r\n\r\n    if (policyName == null)\r\n    {\r\n        var adHocSas = CreateAdHocSasPolicy(permissions);\r\n\r\n        // Generate the shared access signature on the blob, setting the constraints directly on the signature.\r\n        sasBlobToken = blob.GetSharedAccessSignature(adHocSas);\r\n    }\r\n    else\r\n    {\r\n        // Generate the shared access signature on the blob. In this case, all of the constraints for the\r\n        // shared access signature are specified on the container's stored access policy.\r\n        sasBlobToken = blob.GetSharedAccessSignature(null, policyName);\r\n    }\r\n\r\n    return sasBlobToken;\r\n}\r\n\r\npublic static string GetContainerSasToken(CloudBlobContainer container, SharedAccessBlobPermissions permissions, string storedPolicyName = null)\r\n{\r\n    string sasContainerToken;\r\n\r\n    // If no stored policy is specified, create a new access policy and define its constraints.\r\n    if (storedPolicyName == null)\r\n    {\r\n        var adHocSas = CreateAdHocSasPolicy(permissions);\r\n\r\n        // Generate the shared access signature on the container, setting the constraints directly on the signature.\r\n        sasContainerToken = container.GetSharedAccessSignature(adHocSas, null);\r\n    }\r\n    else\r\n    {\r\n        // Generate the shared access signature on the container. In this case, all of the constraints for the\r\n        // shared access signature are specified on the stored access policy, which is provided by name.\r\n        // It is also possible to specify some constraints on an ad-hoc SAS and others on the stored access policy.\r\n        // However, a constraint must be specified on one or the other; it cannot be specified on both.\r\n        sasContainerToken = container.GetSharedAccessSignature(null, storedPolicyName);\r\n    }\r\n\r\n    return sasContainerToken;\r\n}\r\n\r\nprivate static SharedAccessBlobPolicy CreateAdHocSasPolicy(SharedAccessBlobPermissions permissions)\r\n{\r\n    // Create a new access policy and define its constraints.\r\n    // Note that the SharedAccessBlobPolicy class is used both to define the parameters of an ad-hoc SAS, and \r\n    // to construct a shared access policy that is saved to the container's shared access policies. \r\n    return new SharedAccessBlobPolicy()\r\n    {\r\n        // Set start time to five minutes before now to avoid clock skew.\r\n        SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5),\r\n        SharedAccessExpiryTime = DateTime.UtcNow.AddHours(1),\r\n        Permissions = permissions\r\n    };\r\n}\n",
            "sample.dat": "{\n    \"ContainerName\": \"sample-container\",\n    \"BlobName\": \"sample-blob\",\n    \"Permission\": \"Read,Write,Create\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "SasToken-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "authLevel": "function",
                    "name": "req",
                    "type": "httpTrigger",
                    "direction": "in",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "name": "res",
                    "type": "http",
                    "direction": "out"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "SasTokenFSharp",
            "description": "$SasTokenFSharp_description",
            "name": "SAS Token Generator",
            "language": "F#",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "readme.md": "# SAS Token Generator - F<span>#</span>\n\nAn HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container, blob, and permissions. A SAS token provides a secure way for client apps to access particular storage account resources, without giving them the full control of the storage access key.\n\n##Calling the function\n\nTo request a SAS token, send an HTTP post to your function URI, including the API key if you've specified one. The request body format is:\n\n- `container` - *required*. Name of container in storage account\n- `blobName` - *optional*. Used to scope permissions to a particular blob\n- `permissions` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\n\n## How it works\n\nWhen you create a storage account, you get two storage access keys, which provide full control over the storage account contents. Since these keys are admin credentials, they should **never** be distributed with a client app. \n\nInstead, clients should use a shared access signature (SAS) for delegated access to storage resources. A SAS token, which is appended to a storage resource URI, provides access to only a particular resource for a limited period of time. A SAS token can be scoped to a blob or a container and specifies access permissions (such as read or write).\n\nA SAS token is usually generated server-side, using the account access key and the Azure Storage SDK. This sample shows how to use an Azure Function as a SAS token service. Web and mobile clients can call this function to request access to a particular container or blob. By default, the sample creates a token that expires after an hour, but this can be customized.\n\nIf the function will be called from a mobile client or a JavaScript web app, we recommend that you add authentication to your Function using [App Service Authentication/Authorization](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/). The API key is usually insufficent for security purposes since it can be discovered by sniffing traffic or decompiling the client app.\n\n## Learn more\n\n- [Authentication and authorization in Azure App Service](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/)\n- [Shared Access Signatures: Understanding the SAS Model](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)\n- [Create and use a SAS with Blob storage](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-2/)\n- [Delegating Access with a Shared Access Signature](https://msdn.microsoft.com/library/ee395415.aspx)\n- [Establishing a Stored Access Policy](https://msdn.microsoft.com/library/dn140257.aspx)\n",
            "run.fsx": "// An HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container. \n// You can also optionally specify a particular blob name and access permissions. \n// To learn more, see https://github.com/Azure/azure-webjobs-sdk-templates/blob/master/Templates/SasToken-FSharp/readme.md\n\n#r \"System.Configuration\"\n#r \"System.Net.Http\"\n#r \"Microsoft.WindowsAzure.Storage\"\n#r \"Newtonsoft.Json\"\n\nopen System\nopen System.Net\nopen System.Net.Http\nopen System.Configuration\nopen Microsoft.WindowsAzure.Storage\nopen Microsoft.WindowsAzure.Storage.Blob\nopen Newtonsoft.Json\nopen Newtonsoft.Json.Linq\n\n// Request body format: \n// - `container` - *required*. Name of container in storage account\n// - `blobName` - *optional*. Used to scope permissions to a particular blob\n// - `permissions` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. \n//    Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\n\ntype Response = {\n    Token: string\n    Uri: string\n}\n\nlet CreateAdHocSasPolicy permissions =\n    let adHocSas = SharedAccessBlobPolicy()\n    adHocSas.SharedAccessStartTime <- DateTimeOffset.UtcNow.AddMinutes(-5.) |> Nullable\n    adHocSas.SharedAccessExpiryTime <- DateTimeOffset.UtcNow.AddHours(1.) |> Nullable\n    adHocSas.Permissions <- permissions\n    adHocSas\n\nlet GetContainerSasToken (container: CloudBlobContainer) permissions =\n    let adHocSas = CreateAdHocSasPolicy permissions\n    container.GetSharedAccessSignature(adHocSas, null)\n\nlet GetBlobSasToken (container: CloudBlobContainer) blobName permissions =\n    let blob = container.GetBlockBlobReference(blobName)\n    let adHocSas = CreateAdHocSasPolicy permissions\n    blob.GetSharedAccessSignature(adHocSas)\n\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\n    async {\n        let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\n        let json = JObject.Parse(data)\n        let containerJ = json.[\"container\"]\n\n        if containerJ = null then\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"Specify value for container\")\n        else\n        let container = containerJ.Value<string>()\n        let mutable permissions = SharedAccessBlobPermissions.Read\n        let reqPermJ = json.[\"permissions\"]\n\n        if reqPermJ = null then\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"Specify value for 'permissions'\")\n        else\n        let reqPerm = reqPermJ.Value<string>()\n        if not (Enum.TryParse(reqPerm, &permissions)) then\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"Invalid value for 'permissions'\")\n\n        else\n        let storageAccount = CloudStorageAccount.Parse(ConfigurationManager.AppSettings.Item(\"AzureWebJobsStorage\"))\n        let blobClient = storageAccount.CreateCloudBlobClient()\n        let container = blobClient.GetContainerReference(container.ToString())\n        let blobJ = json.[\"blobName\"]\n\n        let sasToken =\n            if blobJ = null then\n                GetContainerSasToken container permissions\n            else\n                GetBlobSasToken container (blobJ.Value<string>()) permissions\n\n        return req.CreateResponse(HttpStatusCode.OK, { Token = sasToken; Uri = container.Uri.ToString() + sasToken })\n    } |> Async.RunSynchronously\n",
            "sample.dat": "{\n    \"container\": \"sample-container\", \"permissions\": \"Read,Write,Create\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "SasToken-JavaScript",
        "function": {
            "bindings": [
                {
                    "authLevel": "function",
                    "type": "httpTrigger",
                    "direction": "in",
                    "name": "req",
                    "methods": [
                        "post"
                    ]
                },
                {
                    "type": "http",
                    "direction": "out",
                    "name": "res"
                }
            ],
            "disabled": false
        },
        "metadata": {
            "defaultFunctionName": "SasTokenJS",
            "description": "$SaasFileTokenNodeJS_description",
            "name": "SAS Token Generator",
            "language": "JavaScript",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "authLevel"
            ]
        },
        "files": {
            "index.js": "// An HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container. \n// You can also optionally specify a particular blob name and access permissions. \n// To learn more, see https://github.com/Azure/azure-webjobs-sdk-templates/blob/master/Templates/SasToken-JavaScript/readme.md\n\nvar azure = require('azure-storage');\n\n// Setup: npm install \n// Go to Function app settings -> App Service settings -> Tools -> Console and type the following:\n//    > cd <functionName>\n//    > npm install\n// Or, go to http://yoursite.scm.azurewebsites.net/DebugConsole navigate to site/wwwroot/YourFunctionName\n// and do npm install in the console window\n\nmodule.exports = function(context, req) {\n    if (req.body.container) {\n        // The following values can be used for permissions: \n        // \"a\" (Add), \"r\" (Read), \"w\" (Write), \"d\" (Delete), \"l\" (List)\n        // Concatenate multiple permissions, such as \"rwa\" = Read, Write, Add\n        context.res = generateSasToken(context, req.body.container, req.body.blobName, req.body.permissions);\n    } else {\n        context.res = {\n            status: 400,\n            body: \"Specify a value for 'container'\"\n        };\n    }\n    \n    context.done();\n};\n\nfunction generateSasToken(context, container, blobName, permissions) {\n    var connString = process.env.AzureWebJobsStorage;\n    var blobService = azure.createBlobService(connString);\n\n    // Create a SAS token that expires in an hour\n    // Set start time to five minutes ago to avoid clock skew.\n    var startDate = new Date();\n    startDate.setMinutes(startDate.getMinutes() - 5);\n    var expiryDate = new Date(startDate);\n    expiryDate.setMinutes(startDate.getMinutes() + 60);\n\n    permissions = permissions || azure.BlobUtilities.SharedAccessPermissions.READ;\n\n    var sharedAccessPolicy = {\n        AccessPolicy: {\n            Permissions: permissions,\n            Start: startDate,\n            Expiry: expiryDate\n        }\n    };\n    \n    var sasToken = blobService.generateSharedAccessSignature(container, blobName, sharedAccessPolicy);\n    \n    return {\n        token: sasToken,\n        uri: blobService.getUrl(container, blobName, sasToken, true)\n    };\n}\n",
            "package.json": "{\n\t\"version\": \"1.0.0\",\n\t\"name\": \"SasToken-JavaScript\",\n\t\"private\": true,\n\t\"dependencies\": {\n\t\t\"azure-storage\": \"1.0.1\"\n\t}\n}",
            "readme.md": "# SAS Token Generator - JavaScript</span>\n\nAn HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container, blob, and permissions. A SAS token provides a secure way for client apps to access particular storage account resources, without giving them the full control of the storage access key.\n\n##Calling the function\n\nTo request a SAS token, send an HTTP post to your function URI, including the API key if you've specified one. The request body format is:\n\n- `container` - *required*. Name of container in storage account\n- `blobName` - *optional*. Used to scope permissions to a particular blob\n- `permissions` - *optional*. Default value is read permissions. Possible values are: \"a\" (Add), \"r\" (Read), \"w\" (Write), \"d\" (Delete), \"l\" (List). Concatenate multiple permissions, such as \"rwa\" = Read, Write, Add\n\nResponse:\n\n- `token` - SAS token, which does **not** include a leading \"?\"\n- `uri` - Resource URI with token appended as query string\n\n## How it works\n\nWhen you create a storage account, you get two storage access keys, which provide full control over the storage account contents. Since these keys are admin credentials, they should **never** be distributed with a client app. \n\nInstead, clients should use a shared access signature (SAS) for delegated access to storage resources. A SAS token, which is appended to a storage resource URI, provides access to only a particular resource for a limited period of time. A SAS token can be scoped to a blob or a container and specifies access permissions (such as read or write).\n\nA SAS token is usually generated server-side, using the account access key and the Azure Storage SDK. This sample shows how to use an Azure Function as a SAS token service. Web and mobile clients can call this function to request access to a particular container or blob. By default, the sample creates a token that expires after an hour, but this can be customized.\n\nIf the function will be called from a mobile client or a JavaScript web app, we recommend that you add authentication to your Function using [App Service Authentication/Authorization](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/). The API key is usually insufficent for security purposes since it can be discovered by sniffing traffic or decompiling the client app.\n\n## Learn more\n\n- [Authentication and authorization in Azure App Service](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/)\n- [Shared Access Signatures: Understanding the SAS Model](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)\n- [Create and use a SAS with Blob storage](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-2/)\n- [Delegating Access with a Shared Access Signature](https://msdn.microsoft.com/library/ee395415.aspx)\n- [Establishing a Stored Access Policy](https://msdn.microsoft.com/library/dn140257.aspx)\n",
            "sample.dat": "{\n    \"container\": \"sample-container\", \"permissions\": \"rwa\"\n}"
        },
        "runtime": "1"
    },
    {
        "id": "ScheduledMail-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "timerTrigger",
                    "name": "myTimer",
                    "schedule": "0 0 23 * * *",
                    "direction": "in"
                },
                {
                    "type": "sendGrid",
                    "name": "$return",
                    "direction": "out",
                    "apiKey": "SendGridApiKey",
                    "from": "Azure Functions <samples@functions.com>",
                    "to": "user@host.com"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ScheduledMailCSharp",
            "description": "$ScheduledMailCSharp_description",
            "name": "ScheduledMail",
            "language": "C#",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "to",
                "from",
                "apiKey",
                "schedule"
            ]
        },
        "files": {
            "run.csx": "#r \"SendGrid\"\n\nusing System;\nusing SendGrid.Helpers.Mail;\nusing Microsoft.Azure.WebJobs.Host;\n\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\n//\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\n//\n// {\n//   \"sendGrid\": {\n//      \"to\": \"user@host.com\",\n//      \"from\": \"Azure Functions <samples@functions.com>\"\n//   }\n// }\npublic static Mail Run(TimerInfo myTimer, TraceWriter log)\n{\n    var today = DateTime.Today.ToShortDateString();\n    log.Info($\"Generating daily report for {today} at {DateTime.Now}\");\n    \n    Mail message = new Mail()\n    {\n        Subject = $\"Daily Report for {today}\"\n    };\n\n    // TODO: Customize this code to generate your specific mail message\n    var orderCount = 100;\n\n    Content content = new Content\n    {\n        Type = \"text/plain\",\n        Value = $\"You had {orderCount} orders today!\"\n    };\n\n    message.AddContent(content);\n    return message;\n}\n"
        },
        "runtime": "1"
    },
    {
        "id": "SendGrid-CSharp",
        "function": {
            "bindings": [
                {
                    "type": "queueTrigger",
                    "name": "order",
                    "direction": "in",
                    "queueName": "samples-orders-csharp"
                },
                {
                    "type": "sendGrid",
                    "name": "$return",
                    "direction": "out",
                    "apiKey": "SendGridApiKey",
                    "from": "Azure Functions <samples@functions.com>",
                    "to": "{CustomerEmail}"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "SendGridCSharp",
            "description": "$SendGridCSharp_description",
            "name": "SendGrid",
            "language": "C#",
            "category": [
                "$temp_category_samples",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "to",
                "from",
                "apiKey"
            ]
        },
        "files": {
            "run.csx": "#r \"SendGrid\"\n\nusing System;\nusing SendGrid.Helpers.Mail;\nusing Microsoft.Azure.WebJobs.Host;\n\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\n//\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\n//\n// {\n//   \"sendGrid\": {\n//      \"to\": \"user@host.com\",\n//      \"from\": \"Azure Functions <samples@functions.com>\"\n//   }\n// }\npublic static Mail Run(Order order, TraceWriter log)\n{\n    log.Info($\"C# Queue trigger function processed order: {order.OrderId}\");\n    \n    Mail message = new Mail()\n    {\n        Subject = $\"Thanks for your order (#{order.OrderId})!\"\n    };\n\n    Content content = new Content\n    {\n        Type = \"text/plain\",\n        Value = $\"{order.CustomerName}, your order ({order.OrderId}) is being processed!\"\n    };\n\n    message.AddContent(content);    \n    return message;\n}\n\npublic class Order\n{\n    public string OrderId { get; set; }\n    public string CustomerName { get; set; }\n    public string CustomerEmail { get; set; }\n}",
            "sample.dat": "{ \"OrderId\": 12345, \"CustomerName\": \"Joe Schmoe\", \"CustomerEmail\": \"joeschmoe@foo.com\" }"
        },
        "runtime": "1"
    },
    {
        "id": "SendGrid-FSharp",
        "function": {
            "bindings": [
                {
                    "type": "queueTrigger",
                    "name": "order",
                    "direction": "in",
                    "queueName": "samples-orders-fsharp"
                },
                {
                    "type": "sendGrid",
                    "name": "$return",
                    "direction": "out",
                    "apiKey": "SendGridApiKey",
                    "from": "Azure Functions <samples@functions.com>",
                    "to": "{CustomerEmail}"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "SendGridFSharp",
            "description": "$SendGridFSharp_description",
            "name": "SendGrid",
            "language": "F#",
            "category": [
                "$temp_category_samples"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "to",
                "from",
                "subject",
                "text",
                "apiKey"
            ]
        },
        "files": {
            "run.fsx": "#r \"SendGrid\"\n\nopen System\nopen SendGrid.Helpers.Mail\n\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\n//\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\n//\n// {\n//   \"sendGrid\": {\n//      \"to\": \"user@host.com\",\n//      \"from\": \"Azure Functions <samples@functions.com>\"\n//   }\n// }\n\n[<CLIMutable>]\ntype Order = {\n    OrderId: string\n    CustomerName: string\n    CustomerEmail: string\n}\n\nlet Run(order: Order, log: TraceWriter) =\n    log.Info(\n        sprintf \"F# Queue trigger function processed order: %s\" order.OrderId)\n\n    let message = new Mail()\n    message.Subject <- sprintf \"Thanks for your order (#%s)!\" order.OrderId\n\n    let content =\n        Content(\n            \"text/plain\",\n            sprintf \"%s, your order (%s) is being processed!\"\n                order.CustomerName order.OrderId\n        )\n\n    message.AddContent(content)\n    message\n",
            "sample.dat": "{ \"OrderId\": 12345, \"CustomerName\": \"Joe Schmoe\", \"CustomerEmail\": \"joeschmoe@foo.com\" }"
        },
        "runtime": "1"
    },
    {
        "id": "SendGrid-JavaScript",
        "function": {
            "bindings": [
                {
                    "type": "queueTrigger",
                    "name": "order",
                    "direction": "in",
                    "queueName": "samples-orders"
                },
                {
                    "type": "sendGrid",
                    "name": "message",
                    "direction": "out",
                    "apiKey": "SendGridApiKey",
                    "from": "Azure Functions <samples@functions.com>",
                    "to": "{customerEmail}"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "SendGridJS",
            "description": "$SendGridNodeJS_description",
            "name": "SendGrid",
            "language": "JavaScript",
            "category": [
                "$temp_category_samples",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "to",
                "from",
                "subject",
                "text",
                "apiKey"
            ]
        },
        "files": {
            "index.js": "var util = require('util');\n\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\n//\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\n//\n// {\n//   \"sendGrid\": {\n//      \"to\": \"user@host.com\",\n//      \"from\": \"Azure Functions <samples@functions.com>\"\n//   }\n// }\nmodule.exports = function (context, order) {\n    context.log('JavaScript queue trigger function processed order', order.orderId);\n\n    context.done(null, {\n        message: {\n            subject: util.format('Thanks for your order (#%d)!', order.orderId),\n            content: [{\n                type: 'text/plain',\n                value: util.format(\"%s, your order (%d) is being processed!\", order.customerName, order.orderId)\n            }]\n        }\n    });\n}",
            "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusQueueTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myQueueItem",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "queueName": "myqueue",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ServiceBusQueueTrigger",
            "defaultFunctionName": "ServiceBusQueueTriggerCSharp",
            "description": "$ServiceBusQueueTriggerCSharp_description",
            "language": "C#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "queueName"
            ]
        },
        "files": {
            "run.csx": "using System;\nusing System.Threading.Tasks;\n\npublic static void Run(string myQueueItem, TraceWriter log)\r\n{\r\n    log.Info($\"C# ServiceBus queue trigger function processed message: {myQueueItem}\");\r\n}\n",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusQueueTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myQueueItem",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "queueName": "myqueue",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ServiceBusQueueTrigger",
            "defaultFunctionName": "ServiceBusQueueTriggerFSharp",
            "description": "$ServiceBusQueueTriggerFSharp_description",
            "language": "F#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "queueName"
            ]
        },
        "files": {
            "run.fsx": "let Run(myQueueItem: string, log: TraceWriter) =\n    log.Info(sprintf \"F# ServiceBus function processed message: %s\" myQueueItem)\n",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusQueueTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "mySbMsg",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "queueName": "myinputqueue",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ServiceBusQueueTriggerJS",
            "description": "$ServiceBusQueueTriggerNodeJS_description",
            "name": "ServiceBusQueueTrigger",
            "language": "JavaScript",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "queueName"
            ]
        },
        "files": {
            "index.js": "module.exports = function(context, mySbMsg) {\n    context.log('JavaScript ServiceBus queue trigger function processed message', mySbMsg);\n    context.done();\n};",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusQueueTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "mySbMsg",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "queueName": "myinputqueue",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ServiceBusQueueTriggerTS",
            "description": "$ServiceBusQueueTriggerNodeTS_description",
            "name": "ServiceBusQueueTrigger",
            "language": "TypeScript",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "queueName"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, mySbMsg: any): void {\n    context.log(`TypeScript ServiceBus queue trigger function processed message: ${mySbMsg}`);\n    context.done();\n};",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusTopicTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "mySbMsg",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "topicName": "mytopic",
                    "subscriptionName": "mysubscription",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ServiceBusTopicTrigger",
            "defaultFunctionName": "ServiceBusTopicTriggerCSharp",
            "description": "A C# function that will be run whenever a message is added to the specified Service Bus topic",
            "language": "C#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "topicName",
                "subscriptionName"
            ]
        },
        "files": {
            "run.csx": "using System;\nusing System.Threading.Tasks;\n\npublic static void Run(string mySbMsg, TraceWriter log)\r\n{\r\n    log.Info($\"C# ServiceBus topic trigger function processed message: {mySbMsg}\");\r\n}\n",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusTopicTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "mySbMsg",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "topicName": "mytopic",
                    "subscriptionName": "mysubscription",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "name": "ServiceBusTopicTrigger",
            "defaultFunctionName": "ServiceBusTopicTriggerFSharp",
            "description": "$ServiceBusTopicTriggerFSharp_description",
            "language": "F#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "topicName",
                "subscriptionName"
            ]
        },
        "files": {
            "run.fsx": "let Run(mySbMsg: string, log: TraceWriter) =\n    log.Info(sprintf \"F# ServiceBus function processed message: %s\" mySbMsg)\n",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusTopicTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "mySbMsg",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "topicName": "mytopic",
                    "subscriptionName": "mysubscription",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ServiceBusTopicTriggerJS",
            "description": "$ServiceBusTopicTriggerNodeJS_description",
            "name": "ServiceBusTopicTrigger",
            "language": "JavaScript",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "topicName",
                "subscriptionName"
            ]
        },
        "files": {
            "index.js": "module.exports = function(context, mySbMsg) {\n    context.log('JavaScript ServiceBus topic trigger function processed message', mySbMsg);\n    context.done();\n};",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "ServiceBusTopicTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "mySbMsg",
                    "type": "serviceBusTrigger",
                    "direction": "in",
                    "topicName": "mytopic",
                    "subscriptionName": "mysubscription",
                    "connection": ""
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "ServiceBusTopicTriggerTS",
            "description": "$ServiceBusTopicTriggerNodeTS_description",
            "name": "ServiceBusTopicTrigger",
            "language": "TypeScript",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": false,
            "userPrompt": [
                "connection",
                "accessRights",
                "topicName",
                "subscriptionName"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, message: any) {\n    context.log(`TypeScript ServiceBus topic trigger function processed message ${message}`);\n    context.done();\n};",
            "sample.dat": "Service Bus Message"
        },
        "runtime": "1"
    },
    {
        "id": "TimerTrigger-CSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myTimer",
                    "type": "timerTrigger",
                    "direction": "in",
                    "schedule": "0 */5 * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "TimerTriggerCSharp",
            "description": "$TimerTriggerCSharp_description",
            "name": "TimerTrigger",
            "language": "C#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "readme.md": "# TimerTrigger - C<span>#</span>\n\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\n\n## How it works\n\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\n\n## Learn more\n\n<TODO> Documentation",
            "run.csx": "using System;\n\npublic static void Run(TimerInfo myTimer, TraceWriter log)\r\n{\r\n    log.Info($\"C# Timer trigger function executed at: {DateTime.Now}\");\r\n}\n",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "TimerTrigger-FSharp",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myTimer",
                    "type": "timerTrigger",
                    "direction": "in",
                    "schedule": "0 */5 * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "TimerTriggerFSharp",
            "description": "$TimerTriggerFSharp_description",
            "name": "TimerTrigger",
            "language": "F#",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "readme.md": "# TimerTrigger - F<span>#</span>\n\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\n\n## How it works\n\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\n\n## Learn more\n\n<TODO> Documentation",
            "run.fsx": "open System\n\nlet Run(myTimer: TimerInfo, log: TraceWriter) =\n    log.Info(\n        sprintf \"F# Timer trigger function executed at: %s\" \n            (DateTime.Now.ToString()))\n",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "TimerTrigger-JavaScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myTimer",
                    "type": "timerTrigger",
                    "direction": "in",
                    "schedule": "0 */5 * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "TimerTriggerJS",
            "description": "$TimerTriggerNodeJS_description",
            "name": "TimerTrigger",
            "language": "JavaScript",
            "category": [
                "$temp_category_core",
                "$temp_category_dataProcessing"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "index.js": "module.exports = function (context, myTimer) {\n    var timeStamp = new Date().toISOString();\n    \n    if(myTimer.isPastDue)\n    {\n        context.log('JavaScript is running late!');\n    }\n    context.log('JavaScript timer trigger function ran!', timeStamp);   \n    \n    context.done();\n};",
            "readme.md": "# TimerTrigger - JavaScript\n\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\n\n## How it works\n\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\n\n## Learn more\n\n<TODO> Documentation",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "TimerTrigger-Powershell",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myTimer",
                    "type": "timerTrigger",
                    "direction": "in",
                    "schedule": "0 */5 * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "TimerTriggerPowerShell",
            "description": "$TimerTriggerPowerShell_description",
            "name": "TimerTrigger",
            "language": "PowerShell",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "readme.md": "# TimerTrigger - PowerShell\n\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every minute.\n\n## How it works\n\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".",
            "run.ps1": "Write-Output \"PowerShell Timer trigger function executed at:$(get-date)\";",
            "sample.dat": ""
        },
        "runtime": "1"
    },
    {
        "id": "TimerTrigger-TypeScript",
        "function": {
            "disabled": false,
            "bindings": [
                {
                    "name": "myTimer",
                    "type": "timerTrigger",
                    "direction": "in",
                    "schedule": "0 */5 * * * *"
                }
            ]
        },
        "metadata": {
            "defaultFunctionName": "TimerTriggerTS",
            "description": "$TimerTriggerNodeTS_description",
            "name": "TimerTrigger",
            "language": "TypeScript",
            "category": [
                "$temp_category_experimental"
            ],
            "enabledInTryMode": true,
            "userPrompt": [
                "schedule"
            ]
        },
        "files": {
            "index.ts": "export function run(context: any, myTimer: any): any {\n    const timeStamp: string = new Date().toISOString();\n\n    if(myTimer.isPastDue) {\n        context.log(`TypeScript is running late!`);\n    }\n    context.log(`TypeScript timer trigger function ran! ${timeStamp}`);\n\n    context.done();\n};",
            "readme.md": "# TimerTrigger - TypeScript\n\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\n\n## How it works\n\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\n\n## Learn more\n\n<TODO> Documentation",
            "sample.dat": ""
        },
        "runtime": "1"
    }
]